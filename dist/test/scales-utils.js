'use strict';

var _tape = require('tape');

var _tape2 = _interopRequireDefault(_tape);

require('babel-polyfill');

var _scalesUtils = require('../lib/utils/scales-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isScaleConsistent(scaleObject, attr) {
  return scaleObject && scaleObject.range && scaleObject.domain && scaleObject.type && scaleObject.attr === attr;
} // Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var _allData = [[{ x: 1 }, { x: 2 }, { x: 3 }, { x: 2 }]];
var _xValue = 20;
var xRange = [0, 100];
var xDomain = [1, 5];
var xType = 'ordinal';
var xDistance = 10;

(0, _tape2.default)('scales-utils/getScaleObjectFromProps with empty props', function t(assert) {
  var nullResult = (0, _scalesUtils.getScaleObjectFromProps)({}, 'x');
  assert.ok(nullResult === null, 'Should return null if no props available.');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScaleObjectFromProps with empty range', function t(assert) {
  var noRangeResult = (0, _scalesUtils.getScaleObjectFromProps)({ _allData: _allData }, 'x');
  assert.ok(noRangeResult === null, 'Should be null if no range is passed');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScaleObjectFromProps with incomplete props', function t(assert) {
  var incompleteResult = (0, _scalesUtils.getScaleObjectFromProps)({ xRange: xRange, _allData: _allData }, 'x');
  assert.ok(isScaleConsistent(incompleteResult, 'x'), 'Should be a consistent scale');
  assert.ok(incompleteResult.type === 'linear', 'Should be linear by detault');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScaleObjectFromProps with all props', function t(assert) {
  var completeResult = (0, _scalesUtils.getScaleObjectFromProps)({ xRange: xRange, _allData: _allData, xDomain: xDomain, xType: xType, xDistance: xDistance }, 'x');
  assert.ok(isScaleConsistent(completeResult, 'x'), 'Should be a consistent scale');
  assert.ok(completeResult.type === xType, 'Should have same type that was passed by detault');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScaleObjectFromProps should not mutate passed domain', function t(assert) {
  var tXDomain = [1, 5];
  var scaleObj = (0, _scalesUtils.getScaleObjectFromProps)({
    xRange: xRange, _adjustBy: ['x'], _adjustWhat: [0], _allData: _allData,
    xDomain: tXDomain, xDistance: xDistance }, 'x');
  assert.deepEqual(scaleObj.domain, [0.5, 5.5], 'Correct adjustment of domain');
  assert.deepEqual(tXDomain, [1, 5], 'original domain object should contain the same values');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScaleObjectFromProps with the value that overrides props', function t(assert) {
  var valueResult = (0, _scalesUtils.getScaleObjectFromProps)({ x: 10, _allData: _allData }, 'x');
  assert.ok(isScaleConsistent(valueResult, 'x'), 'Should be a consistent scale');
  assert.ok(valueResult.isValue === true, 'Should have isValue = true');
  assert.end();
});

(0, _tape2.default)('scales-utils/getScalePropTypesByAttribute', function t(assert) {
  var result = (0, _scalesUtils.getScalePropTypesByAttribute)('size');
  var isValid = true;
  Object.keys(result).forEach(function (key) {
    isValid &= key.indexOf('_size') === 0 || key.indexOf('size') === 0;
  });
  assert.ok(isValid, 'Should return _size or size values');
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeFunctor without props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeFunctor)({ _xValue: _xValue }, 'x');
  assert.ok(result({ x: Math.random() }) === _xValue, 'Fallback value ' + _xValue + ' should be returned by the produced functor');
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeFunctor with props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeFunctor)({ xRange: xRange, _allData: _allData }, 'x');
  var isFunction = typeof result === 'function';
  assert.ok(isFunction, 'Result should be a function');
  if (isFunction) {
    assert.ok(result(_allData[0][0]) === xRange[0], 'Function should reflect values properly');
  }
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeScale without props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeScale)({}, 'x');
  assert.ok(result === null, 'Result should be null');
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeScale with props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeScale)({ xRange: xRange, _allData: _allData }, 'x');
  var isFunction = typeof result === 'function';
  assert.ok(isFunction, 'Result should be a function');
  if (isFunction) {
    assert.ok(result(_allData[0][0].x) === xRange[0], 'Result scale is valid');
  }
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeValue without props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeValue)({ _xValue: _xValue }, 'x');
  assert.ok(result === _xValue, 'Fallback value should be returned');
  assert.end();
});

(0, _tape2.default)('scales-utils/getAttributeValue with valid props', function t(assert) {
  var result = (0, _scalesUtils.getAttributeValue)({ x: 10 }, 'x');
  assert.ok(result === 10, 'The value should be returned');
  assert.end();
});

(0, _tape2.default)('scales-utils/_getSmallestDistanceIndex', function t(assert) {
  var scaleObj = {
    type: 'linear',
    domain: [0, 1],
    range: [0, 1]
  };

  assert.equal(runTest([0, 0, 2]), 1);
  assert.equal(runTest([0, 1, 2]), 1);
  assert.equal(runTest([0, 2, 2]), 2);
  assert.equal(runTest([0, 2, 2]), 2);
  assert.equal(runTest([1, 2, 2]), 2);
  assert.equal(runTest([2, 2, 2]), 1);
  assert.end();

  function runTest(arg) {
    return (0, _scalesUtils._getSmallestDistanceIndex)(arg, scaleObj);
  }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90ZXN0L3NjYWxlcy11dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQW9CQTs7OztBQUNBOztBQUVBOzs7O0FBU0EsU0FBUyxpQkFBVCxDQUEyQixXQUEzQixFQUF3QyxJQUF4QyxFQUE4QztBQUM1QyxTQUFPLGVBQWUsWUFBWSxLQUEzQixJQUFvQyxZQUFZLE1BQWhELElBQ0wsWUFBWSxJQURQLElBQ2UsWUFBWSxJQUFaLEtBQXFCLElBRDNDO0FBRUQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFRCxJQUFNLFdBQVcsQ0FBQyxDQUFDLEVBQUMsR0FBRyxDQUFKLEVBQUQsRUFBUyxFQUFDLEdBQUcsQ0FBSixFQUFULEVBQWlCLEVBQUMsR0FBRyxDQUFKLEVBQWpCLEVBQXlCLEVBQUMsR0FBRyxDQUFKLEVBQXpCLENBQUQsQ0FBakI7QUFDQSxJQUFNLFVBQVUsRUFBaEI7QUFDQSxJQUFNLFNBQVMsQ0FBQyxDQUFELEVBQUksR0FBSixDQUFmO0FBQ0EsSUFBTSxVQUFVLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEI7QUFDQSxJQUFNLFFBQVEsU0FBZDtBQUNBLElBQU0sWUFBWSxFQUFsQjs7QUFFQSxvQkFBSyx1REFBTCxFQUE4RCxTQUFTLENBQVQsQ0FDNUQsTUFENEQsRUFDcEQ7QUFDUixNQUFNLGFBQWEsMENBQXdCLEVBQXhCLEVBQTRCLEdBQTVCLENBQW5CO0FBQ0EsU0FBTyxFQUFQLENBQVUsZUFBZSxJQUF6QixFQUErQiwyQ0FBL0I7QUFDQSxTQUFPLEdBQVA7QUFDRCxDQUxEOztBQU9BLG9CQUFLLHVEQUFMLEVBQThELFNBQVMsQ0FBVCxDQUM1RCxNQUQ0RCxFQUNwRDtBQUNSLE1BQU0sZ0JBQWdCLDBDQUF3QixFQUFDLGtCQUFELEVBQXhCLEVBQW9DLEdBQXBDLENBQXRCO0FBQ0EsU0FBTyxFQUFQLENBQVUsa0JBQWtCLElBQTVCLEVBQWtDLHNDQUFsQztBQUNBLFNBQU8sR0FBUDtBQUNELENBTEQ7O0FBT0Esb0JB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QUEwQixHQUExQixFQUErQixRQUEvQixDQUFQO0FBQ0Q7QUFDRixDQWxCRCIsImZpbGUiOiJzY2FsZXMtdXRpbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTYgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgdGVzdCBmcm9tICd0YXBlJztcbmltcG9ydCAnYmFiZWwtcG9seWZpbGwnO1xuXG5pbXBvcnQge1xuICBnZXRTY2FsZU9iamVjdEZyb21Qcm9wcyxcbiAgZ2V0U2NhbGVQcm9wVHlwZXNCeUF0dHJpYnV0ZSxcbiAgZ2V0QXR0cmlidXRlRnVuY3RvcixcbiAgZ2V0QXR0cmlidXRlU2NhbGUsXG4gIGdldEF0dHJpYnV0ZVZhbHVlLFxuICBfZ2V0U21hbGxlc3REaXN0YW5jZUluZGV4XG59IGZyb20gJy4uL2xpYi91dGlscy9zY2FsZXMtdXRpbHMnO1xuXG5mdW5jdGlvbiBpc1NjYWxlQ29uc2lzdGVudChzY2FsZU9iamVjdCwgYXR0cikge1xuICByZXR1cm4gc2NhbGVPYmplY3QgJiYgc2NhbGVPYmplY3QucmFuZ2UgJiYgc2NhbGVPYmplY3QuZG9tYWluICYmXG4gICAgc2NhbGVPYmplY3QudHlwZSAmJiBzY2FsZU9iamVjdC5hdHRyID09PSBhdHRyO1xufVxuXG5jb25zdCBfYWxsRGF0YSA9IFtbe3g6IDF9LCB7eDogMn0sIHt4OiAzfSwge3g6IDJ9XV07XG5jb25zdCBfeFZhbHVlID0gMjA7XG5jb25zdCB4UmFuZ2UgPSBbMCwgMTAwXTtcbmNvbnN0IHhEb21haW4gPSBbMSwgNV07XG5jb25zdCB4VHlwZSA9ICdvcmRpbmFsJztcbmNvbnN0IHhEaXN0YW5jZSA9IDEwO1xuXG50ZXN0KCdzY2FsZXMtdXRpbHMvZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMgd2l0aCBlbXB0eSBwcm9wcycsIGZ1bmN0aW9uIHQoXG4gIGFzc2VydCkge1xuICBjb25zdCBudWxsUmVzdWx0ID0gZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMoe30sICd4Jyk7XG4gIGFzc2VydC5vayhudWxsUmVzdWx0ID09PSBudWxsLCAnU2hvdWxkIHJldHVybiBudWxsIGlmIG5vIHByb3BzIGF2YWlsYWJsZS4nKTtcbiAgYXNzZXJ0LmVuZCgpO1xufSk7XG5cbnRlc3QoJ3NjYWxlcy11dGlscy9nZXRTY2FsZU9iamVjdEZyb21Qcm9wcyB3aXRoIGVtcHR5IHJhbmdlJywgZnVuY3Rpb24gdChcbiAgYXNzZXJ0KSB7XG4gIGNvbnN0IG5vUmFuZ2VSZXN1bHQgPSBnZXRTY2FsZU9iamVjdEZyb21Qcm9wcyh7X2FsbERhdGF9LCAneCcpO1xuICBhc3NlcnQub2sobm9SYW5nZVJlc3VsdCA9PT0gbnVsbCwgJ1Nob3VsZCBiZSBudWxsIGlmIG5vIHJhbmdlIGlzIHBhc3NlZCcpO1xuICBhc3NlcnQuZW5kKCk7XG59KTtcblxudGVzdCgnc2NhbGVzLXV0aWxzL2dldFNjYWxlT2JqZWN0RnJvbVByb3BzIHdpdGggaW5jb21wbGV0ZSBwcm9wcycsIGZ1bmN0aW9uIHQoXG4gIGFzc2VydCkge1xuICBjb25zdCBpbmNvbXBsZXRlUmVzdWx0ID0gZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMoe3hSYW5nZSwgX2FsbERhdGF9LCAneCcpO1xuICBhc3NlcnQub2soaXNTY2FsZUNvbnNpc3RlbnQoaW5jb21wbGV0ZVJlc3VsdCwgJ3gnKSxcbiAgICAnU2hvdWxkIGJlIGEgY29uc2lzdGVudCBzY2FsZScpO1xuICBhc3NlcnQub2soaW5jb21wbGV0ZVJlc3VsdC50eXBlID09PSAnbGluZWFyJywgJ1Nob3VsZCBiZSBsaW5lYXIgYnkgZGV0YXVsdCcpO1xuICBhc3NlcnQuZW5kKCk7XG59KTtcblxudGVzdCgnc2NhbGVzLXV0aWxzL2dldFNjYWxlT2JqZWN0RnJvbVByb3BzIHdpdGggYWxsIHByb3BzJywgZnVuY3Rpb24gdChhc3NlcnQpIHtcbiAgY29uc3QgY29tcGxldGVSZXN1bHQgPSBnZXRTY2FsZU9iamVjdEZyb21Qcm9wcyhcbiAgICB7eFJhbmdlLCBfYWxsRGF0YSwgeERvbWFpbiwgeFR5cGUsIHhEaXN0YW5jZX0sICd4Jyk7XG4gIGFzc2VydC5vayhpc1NjYWxlQ29uc2lzdGVudChjb21wbGV0ZVJlc3VsdCwgJ3gnKSxcbiAgICAnU2hvdWxkIGJlIGEgY29uc2lzdGVudCBzY2FsZScpO1xuICBhc3NlcnQub2soY29tcGxldGVSZXN1bHQudHlwZSA9PT0geFR5cGUsXG4gICAgJ1Nob3VsZCBoYXZlIHNhbWUgdHlwZSB0aGF0IHdhcyBwYXNzZWQgYnkgZGV0YXVsdCcpO1xuICBhc3NlcnQuZW5kKCk7XG59KTtcblxudGVzdCgnc2NhbGVzLXV0aWxzL2dldFNjYWxlT2JqZWN0RnJvbVByb3BzIHNob3VsZCBub3QgbXV0YXRlIHBhc3NlZCBkb21haW4nLFxuZnVuY3Rpb24gdChhc3NlcnQpIHtcbiAgY29uc3QgdFhEb21haW4gPSBbMSwgNV07XG4gIGNvbnN0IHNjYWxlT2JqID0gZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMoe1xuICAgIHhSYW5nZSwgX2FkanVzdEJ5OiBbJ3gnXSwgX2FkanVzdFdoYXQ6IFswXSwgX2FsbERhdGEsXG4gICAgeERvbWFpbjogdFhEb21haW4sIHhEaXN0YW5jZX0sICd4Jyk7XG4gIGFzc2VydC5kZWVwRXF1YWwoc2NhbGVPYmouZG9tYWluLCBbMC41LCA1LjVdLCAnQ29ycmVjdCBhZGp1c3RtZW50IG9mIGRvbWFpbicpO1xuICBhc3NlcnQuZGVlcEVxdWFsKHRYRG9tYWluLCBbMSwgNV0sXG4gICAgJ29yaWdpbmFsIGRvbWFpbiBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIHNhbWUgdmFsdWVzJyk7XG4gIGFzc2VydC5lbmQoKTtcbn0pO1xuXG50ZXN0KCdzY2FsZXMtdXRpbHMvZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMgd2l0aCB0aGUgdmFsdWUgdGhhdCBvdmVycmlkZXMgcHJvcHMnLFxuICBmdW5jdGlvbiB0KFxuICAgIGFzc2VydCkge1xuICAgIGNvbnN0IHZhbHVlUmVzdWx0ID0gZ2V0U2NhbGVPYmplY3RGcm9tUHJvcHMoe3g6IDEwLCBfYWxsRGF0YX0sICd4Jyk7XG4gICAgYXNzZXJ0Lm9rKGlzU2NhbGVDb25zaXN0ZW50KHZhbHVlUmVzdWx0LCAneCcpLFxuICAgICAgJ1Nob3VsZCBiZSBhIGNvbnNpc3RlbnQgc2NhbGUnKTtcbiAgICBhc3NlcnQub2sodmFsdWVSZXN1bHQuaXNWYWx1ZSA9PT0gdHJ1ZSxcbiAgICAgICdTaG91bGQgaGF2ZSBpc1ZhbHVlID0gdHJ1ZScpO1xuICAgIGFzc2VydC5lbmQoKTtcbiAgfSk7XG5cbnRlc3QoJ3NjYWxlcy11dGlscy9nZXRTY2FsZVByb3BUeXBlc0J5QXR0cmlidXRlJywgZnVuY3Rpb24gdChcbiAgYXNzZXJ0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldFNjYWxlUHJvcFR5cGVzQnlBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpc1ZhbGlkICY9IGtleS5pbmRleE9mKGBfc2l6ZWApID09PSAwIHx8IGtleS5pbmRleE9mKCdzaXplJykgPT09IDA7XG4gIH0pO1xuICBhc3NlcnQub2soaXNWYWxpZCwgJ1Nob3VsZCByZXR1cm4gX3NpemUgb3Igc2l6ZSB2YWx1ZXMnKTtcbiAgYXNzZXJ0LmVuZCgpO1xufSk7XG5cbnRlc3QoJ3NjYWxlcy11dGlscy9nZXRBdHRyaWJ1dGVGdW5jdG9yIHdpdGhvdXQgcHJvcHMnLCBmdW5jdGlvbiB0KGFzc2VydCkge1xuICBjb25zdCByZXN1bHQgPSBnZXRBdHRyaWJ1dGVGdW5jdG9yKHtfeFZhbHVlfSwgJ3gnKTtcbiAgYXNzZXJ0Lm9rKHJlc3VsdCh7eDogTWF0aC5yYW5kb20oKX0pID09PSBfeFZhbHVlLFxuICAgIGBGYWxsYmFjayB2YWx1ZSAke194VmFsdWV9IHNob3VsZCBiZSByZXR1cm5lZCBieSB0aGUgcHJvZHVjZWQgZnVuY3RvcmApO1xuICBhc3NlcnQuZW5kKCk7XG59KTtcblxudGVzdCgnc2NhbGVzLXV0aWxzL2dldEF0dHJpYnV0ZUZ1bmN0b3Igd2l0aCBwcm9wcycsIGZ1bmN0aW9uIHQoYXNzZXJ0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEF0dHJpYnV0ZUZ1bmN0b3Ioe3hSYW5nZSwgX2FsbERhdGF9LCAneCcpO1xuICBjb25zdCBpc0Z1bmN0aW9uID0gdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJztcbiAgYXNzZXJ0Lm9rKGlzRnVuY3Rpb24sICdSZXN1bHQgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKTtcbiAgaWYgKGlzRnVuY3Rpb24pIHtcbiAgICBhc3NlcnQub2socmVzdWx0KF9hbGxEYXRhWzBdWzBdKSA9PT0geFJhbmdlWzBdLFxuICAgICAgJ0Z1bmN0aW9uIHNob3VsZCByZWZsZWN0IHZhbHVlcyBwcm9wZXJseScpO1xuICB9XG4gIGFzc2VydC5lbmQoKTtcbn0pO1xuXG50ZXN0KCdzY2FsZXMtdXRpbHMvZ2V0QXR0cmlidXRlU2NhbGUgd2l0aG91dCBwcm9wcycsIGZ1bmN0aW9uIHQoYXNzZXJ0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEF0dHJpYnV0ZVNjYWxlKHt9LCAneCcpO1xuICBhc3NlcnQub2socmVzdWx0ID09PSBudWxsLCAnUmVzdWx0IHNob3VsZCBiZSBudWxsJyk7XG4gIGFzc2VydC5lbmQoKTtcbn0pO1xuXG50ZXN0KCdzY2FsZXMtdXRpbHMvZ2V0QXR0cmlidXRlU2NhbGUgd2l0aCBwcm9wcycsIGZ1bmN0aW9uIHQoYXNzZXJ0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEF0dHJpYnV0ZVNjYWxlKHt4UmFuZ2UsIF9hbGxEYXRhfSwgJ3gnKTtcbiAgY29uc3QgaXNGdW5jdGlvbiA9IHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbic7XG4gIGFzc2VydC5vayhpc0Z1bmN0aW9uLCAnUmVzdWx0IHNob3VsZCBiZSBhIGZ1bmN0aW9uJyk7XG4gIGlmIChpc0Z1bmN0aW9uKSB7XG4gICAgYXNzZXJ0Lm9rKHJlc3VsdChfYWxsRGF0YVswXVswXS54KSA9PT0geFJhbmdlWzBdLCAnUmVzdWx0IHNjYWxlIGlzIHZhbGlkJyk7XG4gIH1cbiAgYXNzZXJ0LmVuZCgpO1xufSk7XG5cbnRlc3QoJ3NjYWxlcy11dGlscy9nZXRBdHRyaWJ1dGVWYWx1ZSB3aXRob3V0IHByb3BzJywgZnVuY3Rpb24gdChhc3NlcnQpIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0QXR0cmlidXRlVmFsdWUoe194VmFsdWV9LCAneCcpO1xuICBhc3NlcnQub2socmVzdWx0ID09PSBfeFZhbHVlLCAnRmFsbGJhY2sgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkJyk7XG4gIGFzc2VydC5lbmQoKTtcbn0pO1xuXG50ZXN0KCdzY2FsZXMtdXRpbHMvZ2V0QXR0cmlidXRlVmFsdWUgd2l0aCB2YWxpZCBwcm9wcycsIGZ1bmN0aW9uIHQoYXNzZXJ0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEF0dHJpYnV0ZVZhbHVlKHt4OiAxMH0sICd4Jyk7XG4gIGFzc2VydC5vayhyZXN1bHQgPT09IDEwLCAnVGhlIHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCcpO1xuICBhc3NlcnQuZW5kKCk7XG59KTtcblxudGVzdCgnc2NhbGVzLXV0aWxzL19nZXRTbWFsbGVzdERpc3RhbmNlSW5kZXgnLCBmdW5jdGlvbiB0KGFzc2VydCkge1xuICBjb25zdCBzY2FsZU9iaiA9IHtcbiAgICB0eXBlOiAnbGluZWFyJyxcbiAgICBkb21haW46IFswLCAxXSxcbiAgICByYW5nZTogWzAsIDFdXG4gIH07XG5cbiAgYXNzZXJ0LmVxdWFsKHJ1blRlc3QoWzAsIDAsIDJdKSwgMSk7XG4gIGFzc2VydC5lcXVhbChydW5UZXN0KFswLCAxLCAyXSksIDEpO1xuICBhc3NlcnQuZXF1YWwocnVuVGVzdChbMCwgMiwgMl0pLCAyKTtcbiAgYXNzZXJ0LmVxdWFsKHJ1blRlc3QoWzAsIDIsIDJdKSwgMik7XG4gIGFzc2VydC5lcXVhbChydW5UZXN0KFsxLCAyLCAyXSksIDIpO1xuICBhc3NlcnQuZXF1YWwocnVuVGVzdChbMiwgMiwgMl0pLCAxKTtcbiAgYXNzZXJ0LmVuZCgpO1xuXG4gIGZ1bmN0aW9uIHJ1blRlc3QoYXJnKSB7XG4gICAgcmV0dXJuIF9nZXRTbWFsbGVzdERpc3RhbmNlSW5kZXgoYXJnLCBzY2FsZU9iaik7XG4gIH1cbn0pO1xuIl19