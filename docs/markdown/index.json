[{"text":"## Animation\n\nAnimation makes your charts feel physical, it makes them feel alive, shoot it makes them feel l33t. `react-vis` offers a simple portal into the [react-motion](https://github.com/chenglou/react-motion) animation system by exposing a simple animation prop on most components! This prop accepts three types of values:\n\n*Booleans*: if true is present then `react-vis` will use the `no-wobble` preset (see below)\n\n*Strings*: react-motion offers several different motion presets that cover most use cases. To access them set your animation prop to one of [noWobble, gentle, wobbly, stiff].\n\n\n\n*Objects*: react-motion expects an object formatting like `{damping: NUMBER, stiffness: NUMBER}`, and if you want to give us an object like that, we will hand it direct to react-motion. You can also pass an object with `{nonAnimatedProps: ['foo', 'bar']}` to prevent those props from being interpolated by d3-interpolator.\n\n\n\nThe above example has `animation: {damping: 9, stiffness: 300}`!\n\n**NOTE** In Jsx the presence of the animation prop is enough to trigger an animation, eg\n\n```javascript\n<MarkSeries\n  data={nodes}\n  animation\n  colorType={'category'}\n  stroke={'#ddd'}\n  strokeWidth={2}\n  colorRange={colors}\n  />\n```\n\nWill be treated as true. If you want to include the animation prop but not have animation be engaged, you need to use animation={null}!\n","fileName":"animation.md"},{"text":"## ArcSeries:\n\n\n\nThe arc series allows users to specify arbitrary arcs in the plane! This is useful for making pie charts, sunbursts, and anything else circular.\n\n```javascript\n<XYPlot\n  xDomain={[-5, 5]}\n  yDomain={[-5, 5]}\n  width={300}\n  height={300}>\n  <ArcSeries\n    animation\n    radiusType={'literal'}\n    center={{x: -2, y: 2}}\n    data={myData}\n    colorType={'literal'}/>\n</XYPlot>\n```\n\nA key point: XYPlot infers the necessary x and y domains by converting the angular coordinates to cartesian. If you want to guarantee a centered plot it is advisable to set the x and y domain's yourself, as above.\n\n## Data format Reference\n\nArc series works a little bit different than other series. The most natural language to describe arcs is using polar coordinates, so we allow\nusers to write just that:\n\n```javascript\nconst myData = [\n  {angle0: 0, angle: Math.PI / 4, opacity: 0.2, radius: 2, radius0: 1},\n  {angle0: PI / 4, angle: 2 * PI / 4, radius: 3, radius0: 0},\n  {angle0: 2 * PI / 4, angle: 3 * PI / 4, radius: 2, radius0: 0},\n  {angle0: 3 * PI / 4, angle: 4 * PI / 4, radius: 2, radius0: 0},\n  {angle0: 4 * PI / 4, angle: 5 * PI / 4, radius: 2, radius0: 0},\n  {angle0: 0, angle: 5 * PI / 4, radius: 1.1, radius0: 0.8}\n]\n```\n\nangle0 describes the start of the arc in radians, and angle describes the end of the arc, again in radians. radius0 describes the inner distance from the origin, while radius describes the outer distance to the origin. It is recomended to provide all four of these quantities to format your arcs well.\n\n#### angle0\nType: `number`  \nThe start position of the arc in radians. This quantity is returned literally by default.\n\n#### angle\nType: `number`  \nThe end position of the arc in radians. This quantity is returned literally by default.\n\n#### radius0\nType: `number`  \nThe distance between the origin and the inside of the arc. This values is scaled linearly by default\n\n#### radius\nType: `number`    \nThe distance between the origin and the outside of the arc. This values is scaled linearly by default\n\n#### color (optional)\nType: `string|number`  \nThe color of an arc in the series. By default, the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level. See [colors](colors.md)\n\n#### fill (optional)\nType: `string|number`  \nThe inner color of an arc in the series. If `fill` and `color` are provided, `fill` will override `color`. By default, the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop fillType=\"literal\" to the series itself. This property can also be defined on the series level. See [colors](colors.md)\n\n#### stroke (optional)\nType: `string|number`  \nThe outer color of an arc in the series (i.e. its outline). If `stroke` and `color` are provided, `stroke` will override `color`. By default, the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop strokeType=\"literal\" to the series itself. This property can also be defined on the series level. See [colors](colors.md)\n\n#### opacity (optional)\nType: `string|number`  \nDefault: 1  \nThe opacity of an arc in the series, from 0 (transparent) to 1 (opaque).\n\n\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### center  \nType: `Object` of the form `{x, y}`, where x and y are in coordinates\nThis allows users to specify the origin of their arcs.\n\n#### color  \nType: `string|number`\nThe color for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### className (optional)\nType: `string`  \nProvide an additional class name for the series.\n\n#### data\nType: `Array<Object>`  \nArray of data for the series. See above data format reference.\n\n#### fill\nType: `string|number`  \nThe inner color for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### opacity\nType: `string|number`  \nThe opacity for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### stroke\nType: `string|number`  \nThe outer color for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### style (optional)\nType: `object`  \nSVG paths (which is what the arc series is made up of) have numerous manipulable properties, so rather than trying to prescribe all of them as props we offer a port to let you style it for yourself.\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a series, and provides the corresponding event. Unlike onClick, it doesn't pass a specific datapoint.\n\n```jsx\n<ArcSeries\n...\n  onSeriesClick={(event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a series, and provides the corresponding event. Unlike onValueMouseOut, it doesn't pass a specific datapoint.\n\n```jsx\n<ArcSeries\n...\n  onSeriesMouseOut={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a series, and provides the corresponding event. Unlike onValueMouseOver, it doesn't pass a specific datapoint.\n\n```jsx\n<ArcSeries\n...\n  onSeriesMouseOver={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onValueClick\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user clicks on a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<ArcSeries\n...\n  onValueClick={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOut\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user's mouse leaves a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<ArcSeries\n...\n  onValueMouseOut={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOver\nType: `function`\nDefault: none  \nThis handler is triggered either when the user's mouse enters a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<ArcSeries\n...\n  onValueMouseOver={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n","fileName":"arc-series.md"},{"text":"# AreaSeries\n\n\n\nIn addition to the the LineSeries, react-vis offers a similar chart type for area charts. \nLike LineSeries, AreaSeries:\n- are styled at the series level, not at the mark level. \n- can have a curve property for a different interpolation between points.\n\nUnlike LineSeries, AreaSeries:\n- have a fill property. By default, the color property affects both the fill color and the outline color of the area charts. However, these two can be set independently,\n- don't have an API to style the stroke beyond color. It's still possible to use the style property, though. \n- can be stacked,\n- do not have a canvas equivalent. \n\nThe stroke property of an AreaChart creates an outline around the whole shape of the chart (including to its left, right and bottom.) To create a chart that has a fill, no distinct lines to the left, right or bottom, but a different line style at the top, you may create an area chart with a line chart on top.\n\n## Data format reference\n\n#### x\nType: `mumber`  \nLeft-to-right position of marks in the series.\n\n#### y\nType: `number`  \nTop-to-bottom position of the top edge of the series.\n\n#### y0\nType: `number`  \nDefault: 0  \nTop-to-bottom position of the bottom edge of the series.\n\n## API Reference\n\n#### color (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)\nA color for both the fill and the outline of the area series. Will be overridden by both the fill and the stroke property, if provided.\n\n#### curve (optional)\nType: `string|function`  \nDefault: `null`  \nApply the provided or named curve function from the D3 shape library to smooth the line series plot, see [the D3 documentation](https://github.com/d3/d3-shape#curves) for function names and instructions. Providing the function, not the name, will require importing the d3-shape package in order to configure it:\n\n```javascript\n// Setting up with only a name\nconst stringCurveProp = <AreaSeries data={data} curve={'curveMonotoneX'} .../>;\n\nconst configuredCurve = d3Shape.curveCatmullRom.alpha(0.5);\nconst funcCurveProp = <AreaSeries data={data} curve={configuredCurve} .../>;\n```\n\n#### data\nType: `Array<Object>`  \nArray of data for the series. See above data format reference.\n\n#### fill (optional)\nType: `string|number`   \nDefault: see [colors](colors.md)  \nA color for the fill of the area series. Will override the color property if both are provided.\n\n#### opacity (optional)\nType: `number`  \nDefault: 1  \nOpacity of the area chart from 0 (transparent) to 1 (opaque).\n\n#### stroke (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)  \nA color for the outline of the area series. Will override the color property if both are provided.\n\n#### style (optional)\nType: `object`  \nAn object which holds CSS properties that will be applied to the SVG element(s) rendered by the series. This allows you to style series beyond the other explicitly defined properties and without having to use CSS classnames and stylesheets. See [style](style.md)\n\n```jsx\n<AreaSeries\n  data={data}\n  style={{strokeDasharray: \"2 2\"}}\n/>\n```\n\n### Interaction handlers\n\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n```jsx\n<AreaSeries\n...\n  onNearestX={(datapoint, event)=>{\n  \t// does something on mouseover\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on an AreaSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\n<AreaSeries\n...\n  onSeriesClick={(event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves an AreaSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\n<AreaSeries\n...\n  onSeriesMouseOut={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over an AreaSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\n<AreaSeries\n...\n  onSeriesMouseOver={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n\n","fileName":"area-series.md"},{"text":"## Axes\n\n\n\n`XAxis` and `YAxis` shows are responsible for the axis in the chart. They can be used simply\n\n```javascript\n<XYPlot\n  width={300}\n  height={300}>\n  <XAxis />\n  <YAxis />\n  <MarkSeries data={myData}/>\n</XYPlot>\n```\n\nWhich will automatically interpolate across the relevant domains of the data (ie it will present reasonable values for x and y). It can also be used to create more complex axes\n\n\n\nWhich is produced via\n\n```javascript\n<XYPlot width={300} height={300}>\n  <XAxis top={0} hideLine tickValues={[0, 1, 3, 4, 5]} title=\"X\"/>\n  <XAxis tickFormat={v => `Value is ${v}`} tickLabelAngle={-90} />\n  <YAxis hideTicks/>\n  <YAxis left={50} tickFormat={v => v * v}/>\n  <YAxis hideLine left={150} tickFormat={v => WORDS[v]}/>\n  <MarkSeries data={[{x: 0, y: 0}, {x: 5, y: 5}]} opacity={0} opacityType=\"linear\"/>\n</XYPlot>\n```\n\n\n## API Reference\n\n#### title (optional)\nType: `string`  \nShows the title for the axis.\n\n#### orientation (optional)\nType: `'top'|'left'|'bottom'|'right'`  \nThe position of the axis inside the chart.\nBy default **it is already set** to `'bottom'` for `XAxis` and to `'left'` for `YAxis`. Similar to how the axis are oriented in d3-axis.\n\n#### tickTotal (optional)\nType: `number`  \nTotal number of ticks on the axis. Already set by default. Similar to the `tickTotal()` method of d3-axis.\n\n#### tickValues (optional)\nType: `Array<*>`  \nAn array of values (not coordinates!) that where the ticks should be shown. Similar to the `tickValues()` method of d3-axis.\n\n#### tickFormat (optional)\nType: `function(*)`  \nFormat function for the tick label. Similar to the `tickFormat()` method of d3-axis. Typically the value that is return is a string or a number, however this function also supports rendering svg react elements. To wit, I could have formatting function like\n\n```javascript\nfunction myFormatter(t) {\n  return (<tspan>\n    <tspan x=\"0\" dy=\"1em\">MY VALUE</tspan>\n    <tspan x=\"0\" dy=\"1em\">{t}</tspan>\n  </tspan>);\n}\n```\n\n#### tickSize (optional)\nType: `number`  \nDefault: `6`  \nTick size for the axis. Sets both inner and outer sizes of the tick line. Similar to the `tickSize()` method of d3-axis.\n\n#### tickSizeOuter (optional)\nType: `number`  \nDefault: `null`\nTick size for the axis. Sets the outer size of the tick line. Similar to the `tickSizeOuter()` method of d3-axis.\n\nNOTE: 1.0.0 and onwards now properly draws outer tick using this value. Previously, this value affected the drawing of inner tick.\n\n#### tickSizeInner (optional)\nType: `number`  \nDefault: `null`\nTick size for the axis. Sets the inner size of the tick line. Similar to the `tickSizeInner()` method of d3-axis.\n\nNOTE: v1.0.0+ properly draws inner tick using this value. Previously, this value affected the drawing of outer tick.\n\n#### tickPadding (optional)\nType: `number`  \nDefault: `2`  \nDistance between the tick and the text of the tick in pixels. Similar to the `tickPadding()` method of d3-axis.\n\n#### tickLabelAngle (optional)\nType: `number`  \nDefault: `0`  \nThe angle of the tick label. Can be used to fit the long labels of the axis without truncation.\n\n#### left (optional)\nType: `number`  \nHorizontal position of the axis in pixels. **Already set by default**, but can be overridden by the user.\n\n#### top (optional)\nType: `number`  \nVertical position of the axis in pixels. **Already set by default**, but can be overridden by the user.\n\n#### width (optional)\nType: `number`  \nWidth of the axis in pixels. **Already set by default**, but can be overridden by the user.\n\n#### height (optional)\nType: `number`  \nHeight of the axis in pixels. **Already set by default**, but can be overridden by the user.\n\n#### animation (optional)\nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n### style (optional)\nType: `object`\nAn object that contains CSS properties with which the axis component can be entirely re-styled.\nAs the Axis component is composite, it is possible to style its different parts individually. See [style](style.md)\n\nThe various parts of the axis can be styled by passing an object to the `line`, `ticks`, `text` and `title` properties:\n\n```jsx\n<XAxis title=\"X Axis\" style={{\n  line: {stroke: '#ADDDE1'},\n  ticks: {stroke: '#ADDDE1'},\n  text: {stroke: 'none', fill: '#6b6b76', fontWeight: 600}\n}}/>\n```\n","fileName":"axes.md"},{"text":"# Bar Series\n\n**TLDR**: use bar series to make bar charts, but not histograms.\n\nBar series allows users to construct charts that contain rectangles that are oriented either left-right or top-bottom. This type of series is generally used to visualize mappings of categorical data to quantitative data. For instance if you had counts of pigeon sightings by season, that would be a perfect bar series (`[{x: 'winter', y: 10}, {x: 'spring', y: 100}, {x: 'summer', y: 10000}, {x: 'fall', y: 10}]`), while if that data was represented as the individual records of your sightings of pigeons (`[{x: May 1st 2pm}, {x: May 12th 1am}]`) you might either want a mark-series (to make a scatterplot) or a rect-series (to make a histogram).\n\n\n\nBar series come in two flavors, `HorizontalBarSeries` and `VerticalBarSeries`. VerticalBarSeries have vertical bars, HorizontalBarSeries have horizontal bars, plain and simple!\n\n\n\n## Data format Reference\n\nLike other series, it is required that the data be an array of objects, formatted like so:\n\n\n```javascript\nconst myData = [\n  {x: 'A', y: 10},\n  {x: 'B', y: 5},\n  {x: 'C', y: 15}\n]\n```\n\nWhere x and y are required quantities and additional properties may be stapled on.\n\n#### x\nType (VerticalBarSeries): `string|number`  \nType (HorizontalBarSeries): `number`\nThe x position in coordinates of the box to be used. This quantity is treated as a category (at least in VerticalBarSeries) and so considers the exact left-right positioning to be not that important (which is something to watch out for if you are providing exact numbers, in such a case it is better to the rect-series).\n\n#### y\nType (VerticalBarSeries): `number`  \nType (HorizontalBarSeries): `string|number`\nThe y position in coordinates of the box to be used. For VerticalBarSeries this value is considered a number, and is scaled against it's domain into pixels.\n\n#### color (optional)\nType: `string|number`\nThe color of a bar in the series. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level.\n\n#### opacity (optional)\nType: `number|Object`  \nOpacity of the individual box to be rendered. By default opacity is scaled by `literal`, so the exact value provided will be used. This property can also be defined on the series level.\n\n#### stroke (optional)\nType: `number|Object`  \nThe color of the outline of the box to be rendered. When this value is not provided the color attribute is used instead. This property can also be defined on the series level.\n\n#### fill (optional)\nType: `number|Object`  \nThe color of the inside of the box to be rendered. When this value is not provided the color attribute is used instead. This property can also be defined on the series level.\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### color\nType: `string|number`\nThe color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### cluster\nSupply a clustering key for this series.\nWhen used with the `stackBy` attribute, creates a clustered stacked bar chart. Returning to our pigeon example from earlier, if you had multiple years of pigeon sightings by season and you wanted to compare the season, clustering would be a great way to do that.\n\n\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n#### fill\nType: `string|number`\nThe inner color for all elements in the series, this property will be over-ridden by fill specified in the data attribute. See [colors](colors.md)\n\n#### opacity\nType: `string|number`\nThe opacity for all elements in the series, this property will be over-ridden by color specified in the data attribute.)\n\n#### stroke\nType: `string|number`\nThe outer color for all elements in the series, this property will be over-ridden by stroke specified in the data attribute. See [colors](colors.md)\n\n### style\nType: `object`\nA list of CSS properties to style the series outside of the explicitly set properties. Note that it will override all other properties (ie fill, stroke, opacity, color). See [style](style.md)\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a series, and provides the corresponding event. Unlike onClick, it doesn't pass a specific datapoint.\n\n```jsx\n<BarSeries\n...\n  onSeriesClick={(event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a series, and provides the corresponding event. Unlike onValueMouseOut, it doesn't pass a specific datapoint.\n\n```jsx\n<BarSeries\n...\n  onSeriesMouseOut={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a series, and provides the corresponding event. Unlike onValueMouseOver, it doesn't pass a specific datapoint.\n\n```jsx\n<BarSeries\n...\n  onSeriesMouseOver={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onValueClick\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user clicks on a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<BarSeries\n...\n  onValueClick={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOut\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user's mouse leaves a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<BarSeries\n...\n  onValueMouseOut={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOver\nType: `function`\nDefault: none  \nThis handler is triggered either when the user's mouse enters a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<BarSeries\n...\n  onValueMouseOver={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n","fileName":"bar-series.md"},{"text":"## Borders\n\nSometimes when modifying the domain of the XYPlot it can be useful to enforce a border, so that some components appear, and others do not. One way to do this is to use the `Borders` component. It is a simple component that creates rectangles the directly correspond to the margins of the plot.\n\n\n\nFor example, a set up like this:\n\n```jsx\n<XYPlot xDomain={[1.2, 3]} yDomain={[11, 26]} width={300} height={300}>\n  <AreaSeries\n    data={[\n      {x: 1, y: 10, y0: 1},\n      {x: 2, y: 25, y0: 5},\n      {x: 3, y: 15, y0: 3}\n    ]}/>\n  <Borders style={{\n    bottom: {fill: '#fff'},\n    left: {fill: '#fff'},\n    right: {fill: '#fff'},\n    top: {fill: '#fff'}\n  }}/>\n  <XAxis />\n  <YAxis />\n  <AreaSeries\n    data={[\n      {x: 1, y: 5, y0: 6},\n      {x: 2, y: 20, y0: 11},\n      {x: 3, y: 10, y0: 9}\n    ]}/>\n</XYPlot>\n```\n\nwould cause the first area series to be truncated underneath the borders, while the second one would not be! This level of granular border control can be useful if you are using multiple kinds of series, for instance if you have a mark series that you wish to show the entire mark for, and a line series that you are alright with truncating at the border.\n\n## API Reference\n\n### className (optional)\nType: `String`\nA class name to apply to each of the borders, as well as the root border container. It will be enumerates on top the borders using suffixes, eg if className={\"my-cool-class\"} the top rectangle will have a class name \"my-cool-class-top\".\n\n### Style (optional)\nType: `Object`\nYou can pass a style object to your Hint component to apply your own styles. See [style](style.md)\n```jsx\n<Borders style={{\n  bottom: {fill: '#fff'},\n  left: {fill: '#fff'},\n  right: {fill: '#fff'},\n  top: {fill: '#fff'}\n}}/>\n```\n\nBecause border its made up of four individual rectangular components (there being four borders on an XYPlot) it is advisable to specify styles for all four rectangles. This can be done using either the style object or css-classes. Alternatively, if all the borders should be treated the same, this can be achieved by supplying an all object to style. This can be then over-ridden:\n\n```jsx\n<Borders style={{\n  all: {fill: '#fff'}\n  bottom: {fill: '#0f0'}\n}}/>\n```\n","fileName":"borders.md"},{"text":"## Color\n\nColor can be set and affected in many ways in React-vis. \nThe main principles are:\n* sensible defaults - your chart should look good even if you don't do anything;\n* respect of specificity - you can change things at a high level (ie <XYPlot /> component) but override this at the series level and, when relevant, at the mark level. \n* flexibility - everything down to the humble tick can be colored and recolored. \n\n### Setup\n\nIn this document, let's look at how different color choices affect 3 different mini charts. \nEach chart in the doc is made of 3 series with x going from 0 to 9 and random values of y between 0 and 10. The left-most chart is made of VerticalBarSeries, the middle one is made of 3 LineSeries, and the right-most one is made of MarkSeries.\n\nSo it goes like this:\n```jsx\n<XYPlot height={200} width={200}>\n  <VerticalBarSeries data={series1}/>\n  <VerticalBarSeries data={series2}/>\n  <VerticalBarSeries data={series3}/>\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={series1}/>\n  <LineSeries data={series2}/>\n  <LineSeries data={series3}/>\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <MarkSeries data={series1}/>\n  <MarkSeries data={series2}/>\n  <MarkSeries data={series3}/>\n</XYPlot>\n```\n\n### Cases\n\n#### We do nothing:\n\n\nWith no color instruction, colors are automatically set by series according to the default react-vis palette, which is: \n\n\n\n#### We specify color in XYPlot\n\n```jsx\n<XYPlot height={200} width={200} color=\"red\">\n  <VerticalBarSeries data={series1}/>\n  <VerticalBarSeries data={series2}/>\n  <VerticalBarSeries data={series3}/>\n</XYPlot>\n<XYPlot height={200} width={200} stroke=\"red\">\n  <LineSeries data={series1}/>\n  <LineSeries data={series2}/>\n  <LineSeries data={series3}/>\n</XYPlot>\n<XYPlot height={200} width={200} color=\"red\">\n  <MarkSeries data={series1}/>\n  <MarkSeries data={series2}/>\n  <MarkSeries data={series3}/>\n</XYPlot>\n```\n\n\n\nWithout any further instruction, all the series are red. Note that in the case of LineSeries, we have to use stroke instead of color for this effect to work. \n\n#### We specify color by series\n\nThe next step is passing colors to by series. When we do that, we add a color prop to each series component: \n\n```jsx\n<LineSeries data={series1} color=\"1\" />\n<LineSeries data={series2} color=\"red\" />\n```\n\nHow this color information is going to be treated depends on a number of factors.\n\n##### Color scales\nOnce it's passed through series, color works like a [scale](scales-and-data.md); in other words, it transforms data into a visual representation.\nThere are several types of scales. \n\nA linear scale works with a range of numerical values on one hand (\"domain\"), and two colors on the other hand (\"range\"). If given a numerical value in the domain, it transforms it into a color in the range depending on how far into the domain that value was. If given the minimum value of the domain, the scale will retrun the first color of the range. If given the maximum value of the domain, it will return the second color of the range. And if given a value in between, it will return an interpolation between these two colors - the closer that value is from the minimum, the more it will look like the first color, and the closer it is to the maximum, the more it will look like the second. Else, it's a proportional mix of the two. \n\nFor example, if a domain is [0, 1] and the range is ['black', 'white'], 0 will become 'black', 1 will become 'white', and 0.2 will become '#333333' (20% between black and white)\n\nThe linear scale can be extended to work with multi-point domains and range. If you pass 3 (ordered) values to the domain, and 3 values to the range, when given a data point, the scale will figure out which segment of the domain this data point corresponds to, and will match it with the corresponding segment of the range. \n\nIf our domain is [0, 1, 2] and our range is now ['black', 'white', 'blue'], 0.2 will still be '#333333' (20% between the first 2 values), but 1.5 will become '#8080ff' (halfway between white and blue)\n\nA categorical color scale associates a discrete number of values (also called domain) to a discrete number of colors (also called range). One big difference is that the values can be number or strings. \nFor instance, if a categorical color scale has the domain: ['yes', 'maybe', 'no'] and the range ['blue', 'yellow', 'red'], it will transform 'yes' into 'blue' and 'no' into 'red'. There will be no interpolation. If it finds a value which is not in its domain, it will return undefined (which will be represented in black). \n\nFinally, the literal color scale just returns whatever is provided as is. With a literal color scale, we can have color names in the dataset, and they will be used without transformation.\n\n##### Categorical colors at series level\n\n\n\nFor this example, the XYPlot props are:\n\n```jsx\n<XYPlot height={200} width={200}\n  colorType=\"category\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <VerticalBarSeries data={series1} color={0} />\n  <VerticalBarSeries data={series2} color={1} />\n  <VerticalBarSeries data={series3} color={2} />\n</XYPlot>\n<XYPlot height={200} width={200}\n  colorType=\"category\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <LineSeries data={series1} color={0} />\n  <LineSeries data={series2} color={1} />\n  <LineSeries data={series3} color={2} />\n</XYPlot>\n<XYPlot height={200} width={200}\n  colorType=\"category\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <LineSeries data={series1} color={0} />\n  <LineSeries data={series2} color={1} />\n  <LineSeries data={series3} color={2} />\n</XYPlot>\n```\n\nAs you can see, __using categorical color at the series level doesn't work for bar charts or scatterplots__. It does for line charts though. \n\n##### Linear colors at series level\n\n\n\n```jsx\n<XYPlot height={200} width={200}\n  colorRange=\"linear\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <VerticalBarSeries data={series1} color={0} />\n  <VerticalBarSeries data={series2} color={1} />\n  <VerticalBarSeries data={series3} color={2} />\n</XYPlot>\n<XYPlot height={200} width={200}\n  colorType=\"linear\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <LineSeries data={series1} color={0} />\n  <LineSeries data={series2} color={1} />\n  <LineSeries data={series3} color={2} />\n</XYPlot>\n<XYPlot height={200} width={200}\n  colorType=\"linear\"\n  colorDomain={[0, 1, 2]}\n  colorRange={myPalette}\n>\n  <LineSeries data={series1} color={0} />\n  <LineSeries data={series2} color={1} />\n  <LineSeries data={series3} color={2} />\n</XYPlot>\n```\n\nLikewise, __using linear color at the series level only works for line charts__.\n\n##### Literal colors at series level\n\n\n\n```jsx\n<XYPlot height={200} width={200}>\n  <VerticalBarSeries data={series1} color=\"#cd3b54\" />\n  <VerticalBarSeries data={series2} color=\"#59b953\" />\n  <VerticalBarSeries data={series3} color=\"#ba4fb9\" />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={series1} color=\"#cd3b54\" />\n  <LineSeries data={series2} color=\"#59b953\" />\n  <LineSeries data={series3} color=\"#ba4fb9\" />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={series1} color=\"#cd3b54\" />\n  <LineSeries data={series2} color=\"#59b953\" />\n  <LineSeries data={series3} color=\"#ba4fb9\" />\n</XYPlot>\n```\n\nHowever, setting color at the series level works for all kinds of charts. It's not even necessary to specify a color type, a domain or a range.\n\n#### We specify color information at mark level\n\nFor this second series of charts, we are going to specify color information inside of our dataset (ie the series which will be passed to the props \"data\"). \nPreviously, our datasets only included x and y information: \n```js\nconst series1 = [\n  {x: 0, y: 2},\n  {x: 1, y: 6},\n  ...\n];\n```\nNow, they will have a color information as well. \n* For our categorical examples, that color value will be a random integer between 0 and 10.\n* For our linear examples, that color value will be a random number between 0 and 10 (not necessarily an integer).\n* Finally, for our literal example, the color information will be the name of a color in hex format.\n\n\n##### Categorical colors at mark level\n\n\n```jsx\n<XYPlot height={200} width={200} colorType=\"category\">\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\">\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\">\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nSo what happens here?\n\nFor line charts, __nothing!__ They ignore colors at mark level. So they behave just like the default case (as if we passed no color information at all)\n\nFor the 2 other charts, marks are colored according to the default extended palette:\n\n\n\nHere, I have specified the colorType prop at the XYPlot level. I could have done so at the series level, inside of each series component (it cascades down). However, I haven't specified a colorRange or a colorDomain. \n\nIt's going to use the default extended palette as the color range. We'll override this in the next example. As for domain, it's going to associate the first color value it finds in the dataset with the first color of the palette, the second distinct color it finds with the second color of the palette, and so on and so forth. \nWith this syntax, we'll render marks which have different color information in different colors, but we don't control which color. If we want to control which color a specific value is going to be associated with, we have to pass a colorDomain.\n\n##### Categorical colors at mark level, custom palette\n\n\n```jsx\n<XYPlot height={200} width={200} colorType=\"category\" colorRange={myPalette}>\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\" colorRange={myPalette}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\" colorRange={myPalette}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nThis time, I'm passing a custom palette: \n\n\n\nBehavior for line chart is still identical, but the colors are different for our bar charts and scatterplots. As I'm not passing a color domain, I still don't control which value will be associated with which color - not super important since my color values are random numbers. But if order matters, a colorDomain is required.\n\n##### Linear colors at mark level, default palette\n\n\n\n```jsx\n<XYPlot height={200} width={200}>\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nThe linear color scale is the default color scale. So, to get that behavior, we don't need to specify this colorType in XYPlot. Its associated color range was conceived by someone who really likes orange:\n\n\n\nI haven't specified the color range either. React-Vis will compute it by looking at the minimum and maximum value associated with color in all the series of a given XYPlot, and use that as the domain. \n\nThe line charts are still unaffected.\n\n##### Linear colors at mark level, custom palette\n\n\n\n```jsx\n<XYPlot height={200} width={200} colorRange={['#c7e9c0', '#00441b']}>\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorRange={['#c7e9c0', '#00441b']}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorRange={['#c7e9c0', '#00441b']}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nHere's the same code, but we define the color range. This green palette comes from ColorBrewer. \n\n##### Literal colors at mark level, default palette\n\n\n\n```jsx\n<XYPlot height={200} width={200} colorType=\"literal\"}>\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"literal\"}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"literal\"}>\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nFinally, we can pass literal color names in our dataset from our custom palette. The line charts are still not affected. \n\n### Going beyond\n\n#### Independently control fill and stroke\n\nThe line chart series (LineSeries) is only a line, but most other series (AreaSeries, ArcSeries, BarSeries, HeatmapSeries, MarkSeries, RectSeries and their derivatives, including LineMarkSeries) involve 2D shapes that have both a fill color and a stroke color.\n\nIn SVG, those correspond to the fill and the stroke css properties (fillStyle and strokeStyle in canvas). \n\nWhen we pass color information, we set both the fill and stroke. However, we can set them independently by using \"fill\" or \"stroke\" instead of color.\n\nAs of this writing, ContourSeries and PolygonSeries don't follow this model and their color can only be controlled by \"color\". \n\n\n\n```jsx\n<XYPlot height={200} width={200} colorType=\"category\" stroke=\"#f70\">\n  <VerticalBarSeries data={seriesWithColor1} />\n  <VerticalBarSeries data={seriesWithColor2} />\n  <VerticalBarSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\" stroke=\"#f70\">\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n<XYPlot height={200} width={200} colorType=\"category\" stroke=\"#f70\">\n  <LineSeries data={seriesWithColor1} />\n  <LineSeries data={seriesWithColor2} />\n  <LineSeries data={seriesWithColor3} />\n</XYPlot>\n```\n\nHere, we set a stroke value at the XYPlot level for all of our charts. What happens?\n\nThe bar chart outerbox is now of that color,\n\nThe line series are now represented in that color - this takes over the default behavior, \n\nThe scatterplot dots are also now surrounded with that color.\n\nNote that in the case of a LineMarkSeries (a combination of a LineSeries and a MarkSeries) the stroke property will control both the color of the line and the stroke of the marks. If you want a different color, you can just instead create a LineSeries and a MarkSeries with the same data:\n\n\n\n```jsx\n<XYPlot height={200} width={600}>\n  <LineSeries data={series1} color={myPalette[0]} />\n  <MarkSeries data={series1} color={myPalette[0]} stroke=\"white\" />\n  <LineSeries data={series2} color={myPalette[1]} />\n  <MarkSeries data={series2} color={myPalette[1]} stroke=\"white\" />\n  <LineSeries data={series3} color={myPalette[2]} />\n  <MarkSeries data={series3} color={myPalette[2]} stroke=\"white\" />\n</XYPlot>\n```\n\nHere, I want my dots to have a white outline. \nWhy did I specify the color of each of my series? You might have to scroll all the way to the top for the answer! If I had done nothing all the colors of my series would have been taken from the default palette for each new series. So the first line series would have had the first color, then the first mark series would have had the _second_ color... and so on and so forth. By specifying a color, we are guaranteeing that the dots and the lines have the same color.\n\n#### Using styles\n\nWe can pass style information to anything - XYPlot, series, mark - and override the look and feel of that element. Styles don't have to be static objects - they can be computed at run time. Styles are a different way to control colors. While using the color prop, or a color property in a dataset, can be much more concise, everything can be affected by styles - including non-mark elements such as ticks or gridlines. See [style](style.md) for more info.\n\n#### Using specificity\n\nWe've seen that we can set color information at the plot level, at the series level and at the mark level. But what happens when we do it at several levels at the same time? The most specific wins. \n\nIf you need to color one element (say, one mark) differently from all the others, you can specify color at a higher level (say, the series or the plot) and only pass color information to the exception, rather than pass color information to all elements. \n\n\n\n```jsx\n  <XYPlot {...defaultXYPlotProps} color=\"#12939A\" colorType=\"literal\">\n    <VerticalBarSeries data={seriesWithOneElementColored} />\n  </XYPlot>\n  <XYPlot {...defaultXYPlotProps} stroke=\"#e5e5e5\" strokeType=\"literal\">\n    <LineSeries data={series1} />\n    <LineSeries data={series2} />\n    <LineSeries data={series3} stroke=\"#FF9833\"/>\n  </XYPlot>\n  <XYPlot {...defaultXYPlotProps} color=\"#12939A\" colorType=\"literal\" stroke=\"white\" >\n    <MarkSeries data={series1} />\n    <MarkSeries data={series2} />\n    <MarkSeries data={seriesWithOneElementColored} color=\"#4fb79b\"/>\n  </XYPlot>\n  \n```\n\nNotes:\n\n* For the line series, which behave differently than other series, you must use stroke instead of color for this to work. \n* For the scatterplot series, I'm using specificity twice: there's a color at the plot level, overridden by a color at the first series level, overridden by a color on the 7th mark of the series.\n\n#### Using gradients\n\nWhy use a boring solid color when you can use gradients? We're not sure either! Once you define gradients (see [gradients](gradients.md)) you can use them instead of color (or fill, or stroke) at the series level.\n\n\n\n```jsx\n  const gradient = (<GradientDefs>\n    <linearGradient\n        id=\"myGradient\"\n        gradientUnits=\"userSpaceOnUse\"\n        x1=\"0\" y1=\"0\" x2=\"200\" y2=\"200\">\n        <stop offset=\"10%\" stopColor=\"#c6e48b\" />\n        <stop offset=\"33%\" stopColor=\"#7bc96f\" />\n        <stop offset=\"66%\" stopColor=\"#239a3b\" />\n        <stop offset=\"90%\" stopColor=\"#196127\" />\n    </linearGradient>\n  </GradientDefs>);\n  return (<div style={{display: 'flex'}}>\n    <XYPlot height={200} width={200}>\n      {gradient}\n      <VerticalBarSeries data={series1} color={'url(#myGradient)'} />\n    </XYPlot>\n    <XYPlot height={200} width={200}>\n      {gradient}\n      <LineSeries data={series1} color={'url(#myGradient)'} />\n    </XYPlot>\n    <XYPlot height={200} width={200}>\n      {gradient}\n      <MarkSeries data={series1} color={'url(#myGradient)'} />\n    </XYPlot>\n  </div>)\n```\n\nNote that I'm using the userSpaceOnUse gradient unit, so the colors are set independently of the size of the object. I'm borrowing the colors of the gradient from the ones used on the activity sparklines in GitHub. \n\n\n","fileName":"colors.md"},{"text":"## ContourSeries\n\nThe contour series allows for the easy creation of contour density plots. These can be more effective for visualizing heat map data than a rectangular heat map! Given a number of points in a space the relative contour lines are computed, so as to simplify the output into a more legible format!\n\n\n\nThe ContourSeries expects a similar data input as would be fed to either the MarkSeries or the HeatmapSeries. It can be as easy as just providing a well formatted data prop (an array of object containing numerically valued x and y keys), or more complex such as below:\n\n```javascript\n<XYPlot\n  xDomain={[40, 100]}\n  yDomain={[1.5, 8]}\n  width={600}\n  height={300}>\n  <ContourSeries\n    animation\n    className=\"contour-series-example\"\n    style={{\n      stroke: '#125C77',\n      strokeLinejoin: 'round'\n    }}\n    colorRange={[\n      '#79C7E3',\n      '#FF9833'\n    ]}\n    data={data}/>\n</XYPlot>\n```\n\n## API reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### bandwidth (optional)  \nA parameter that directly maps into d3-contour's bandwidth parameter. See the [docs for more](https://github.com/d3/d3-contour#density_bandwidth)\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### data\nType: `Array<Object>`\nArray of data for the series. Follows the usual pattern of an array of objects formatted with x and y coordinates, [{x: 0, y: 0}, ...].\n\n### style\nType: `object`\nA list of CSS properties to style the series outside of the explicitly set properties. Note that it will override all other properties (ie fill, stroke, opacity, color). See [style](style.md)\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n","fileName":"contour-series.md"},{"text":"## Crosshair\n\n\n\n`Crosshair` is a tooltip for multiple values at the same time. Its purpose is to combine several values with the similar X coordinate in one tooltip. Crosshair is automatically aligned by the x coordinate depending on what values are passed.\nIn case if custom representation of crosshair is needed, the component is able to wrap the user's JSX. In this case no CSS is applied to that. Here's a short example:\n\n```jsx\n<Crosshair values={myValues}>\n  <div style={{background: 'black'}}>\n    <h3>Values of crosshair:</h3>\n    <p>Series 1: {myValues[0].x}</p>\n    <p>Series 2: {myValues[1].x}</p>\n  </div>\n</Crosshair>\n```\n\n#### values\nType: `Array<Object>`  \nThe array of data points to show the crosshair at. Crosshair will automatically align to the horizontal position of the points passed there.\n\n#### titleFormat (optional)\nType: `function`  \nThe function that formats the title for the crosshair. Receives the list of data points, should return an object containing `title` and `value` properties.  \n_Note: please pass custom contents in case if you need different look for the crosshair._\n\n#### itemsFormat (optional)\nType: `function`  \nThe function that formats the list of items for the crosshair. Receives the list of data points, should return an array of objects containing `title` and `value` properties.  \n_Note: please pass custom contents in case if you need different look for the crosshair._\n","fileName":"crosshair.md"},{"text":"## CustomSVGSeries\n\nWhen creating visualizations, it is sometimes necessary to get your hands dirty and completely take control over what SVG components will be shown. This could be necessary in situations where you have predefined SVG code that you just want to appear the way you drew it in Sketch (but positioned using coordinates), or maybe you have multiline text annotations that you want to formatted in a particular way, or you just want to use an alternative type of mark instead of the usual scatterplot mark to differentiate series in a set. To serve these and many other tasks, we use the CustomSVGSeries.\n\n\n\nThe premise of the series is that it simply puts a `<g>` element at a desired x,y location, and the offers you a variety of ways to fill in the contents of that `<g>` element. Here's an example of the data format:\n\n```javascript\nconst myData = [\n  {x: 1, y: 10, customComponent: 'circle', size: 10},\n  {x: 1.7, y: 12, size: 20, style: {stroke: 'red', fill: 'orange'}},\n  {x: 2, y: 5},\n  {x: 3, y: 15},\n  {x: 2.5, y: 7, customComponent: (row, positionInPixels) => {\n    return (\n      <g className=\"inner-inner-component\">\n        <circle cx=\"0\" cy=\"0\" r={10} fill=\"green\"/>\n        <text x={0} y={0}>\n          <tspan x=\"0\" y=\"0\">{`x: ${positionInPixels.x}`}</tspan>\n          <tspan x=\"0\" y=\"1em\">{`y: ${positionInPixels.y}`}</tspan>\n        </text>\n      </g>\n    );\n  }}\n]\n```\n\nJust like other series, x and y are used to position the group. The customComponent key word is used to determine how to fill in the svg (see below), and then size is used modify the size of the contents when using a string. Used in context of the series:\n\n```javascript\n<XYPlot width={300} height={300}>\n  <CustomSVGSeries customComponent=\"square\" data={myData} />\n</XYPlot>\n```\n\n### Defining your marks\n\nThe type of custom svg marks can be determined in one of several ways:\n\n- As a string on a series level\n- As a function on a series level\n- As a string on row level\n- As a function on a row level\n\nThere are currently four types of string accessible custom marks: **star**, **square**, **circle**, and **diamond**. If using a string, it can be useful to specify a size for the mark. This is done on a row level (see above data api example), with the size prop. Size is expressed in pixels, and is NOT scaled with the normal react-vis size keyword. They look like this:\n\n\n\nIf using a function to defined your mark, it is important to note that the function receives two arguments (customComponent, positionInPixels), where customComponent is the row of data as you have defined it. Thus if you are defining a function for the series as a whole you can make modifications based on the individual row as you go!\n\n## API reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### customComponent (optional)\nType: `string|function`\nProvides the mark type for the entire series. Defaults to a 'circle'. See `Defining You Marks` above.\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n### style\nType: `object`\nA list of CSS properties to style the series outside of the explicitly set properties. Note that it will override all other properties (ie fill, stroke, opacity, color). See [style](style.md)\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n","fileName":"custom-svg-series.md"},{"text":"## DecorativeAxis\n\n\n\nIn react-vis we try to express all of our components in terms of x and y coordinates. This is splendid and allows to separate a lot of our rendering logic from components! However, sometimes it is necessary to create labels that don't necessarily correspond to the underlying coordinates. For instance in cases of parallel coordinates (above) we want to mark up space in a series of discrete channels to show change across many different variables. To fill this need we use the ```DecorativeAxis``` component!\n\n```javascript\n<XYPlot\n  xDomain={[0, 1]}\n  yDomain={[0, 1]}\n  width={300}\n  height={300}>\n  <DecorativeAxis\n    axisStart={{x: 0, y: 0}}\n    axisEnd={{x: 1, y: 1}}\n    axisDomain={[-10, 100]}\n    />\n</XYPlot>\n```\n\nIn the above example we start be setting our domain on the XYPlot (though this would be accomplished automatically if any of it's children had a data prop), and then specified where in the XY space we want our Axis to be (axisStart/axisEnd). Finally we specify the domain that we wish to show across that axis.\n\n\n\n**WHAT IS THIS FOR** Labeling sections of XY space when we wish the viewer to interpret space in a different way. This could be as part of a Radar chart or radial chart! Or even, the inherently bad Dual Y Axis chart.\n\n**WHAT IS NOT THIS FOR** Using in place of XAxis or YAxis, which should cover most of use cases in which space is being used normally.This type of axis allows for a lot of freedom in it's usage, however that can be dangerous. Most of the time, if you can't get XAxis and YAxis to do what you want, you maybe don't need axes. Be careful!\n\n## API Reference\n\n#### axisStart\nType: `Object`\nSpecify a start point for the decorativeAxis. It should be expressed in terms of coordinates (not pixels!) as a object like ```{x: 10, y: 1}```\n\n#### axisEnd\nType: `Object`\nSpecify a start point for the decorativeAxis. It should be expressed in terms of coordinates (not pixels!) as a object like ```{x: 10, y: 1}```\n\n#### axisDomain\nType: `Array`\nThis array of numbers allows the user to specify the values that will be interpolated across on the axis.\n\n#### tickTotal (optional)\nType: `number`  \nTotal number of ticks on the axis. Already set by default. Similar to the `tickTotal()` method of d3-axis.\n\n#### tickSize (optional)\nType: `number`  \nDefault: `5`  \nTick size for the axis. Sets both inner and outer sizes of the tick line. Similar to the `tickSize()` method of d3-axis.\n\n#### tickValue (optional)\nType: `function(*)`  \nFormat function for the tick label. Similar to the `tickFormat()` method of d3-axis.\n\n#### animation (optional)\nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n### style (optional)\nType: `object`\nAn object that contains CSS properties with which the axis component can be entirely re-styled.\nAs the Axis component is composite, it is possible to style its different parts individually. See [style](style.md)\n\nThe various parts of the axis can be styled by passing an object to the `line`, `ticks`, `text` and `title` properties:\n\n```jsx\n<DecorativeAxis style={{\n  line: {stroke: '#ADDDE1'},\n  ticks: {stroke: '#ADDDE1'},\n  text: {stroke: 'none', fill: '#6b6b76', fontWeight: 600}\n}}/>\n```\n","fileName":"decorative-axis.md"},{"text":"## Flexible plots\n\nBy default, XYPlot requires a width and a height. There are times, however, when you'd like your chart to take all the space it can.\nFor these cases, React-vis provides three different types of `XYPlot` with different flexible dimensions:\n\n  - FlexibleWidthXYPlot\n  - FlexibleHeightXYPlot\n  - FlexibleXYPlot\n\nand the associated helper functions that have been used to create these flexible components.\n\n\n\n```jsx\nimport {\n  FlexibleXYPlot,\n  FlexibleWidthXYPlot,\n  FlexibleHeightXYPlot\n} from 'react-vis';\n```\n\n`FlexibleWidthXYPlot` modifies `XYPlot` so that it no longer requires a width, since it will take all the with in its container div.\nLikewise, `FlexibleHeightXYPlot` modifies `XYPlot` so that is no longer requires a height, and its height will be that of its container div.\nFinally, `FlexibleXYPlot` modifies `XYPlot` so that it no longer requires eiter a width and a height, its dimensions will be that of its container.\n\nThese components can be used exactly as `XYPlot`:\n\n```jsx\n<FlexibleWidthXYPlot height={100}>\n  <VerticalBarSeries data={data} />\n</FlexibleWidthXYPlot>\n\n<FlexibleHeightXYPlot width={100}>\n  <VerticalBarSeries data={data} />\n</FlexibleHeightXYPlot>\n\n<FlexibleXYPlot>\n  <VerticalBarSeries data={data} />\n</FlexibleVisXYPlot>\n```\n\n### No worries about resizing\n\nA flexible plot is useful when you don't know for sure the size of the container where the chart will go.\nOn top of that, flexible plots resize themselves when the window size changes. You can try that by changing the size of this window.\n\n### Size of parent container is not the same as \"all the available space\"\n\nFlexible plots will inherit dimensions from their container. This is not the same thing as taking all the available space; if there are other elements in that container, a flexible plot won't deduce their dimensions from its own.\nFor best results, a flexible plot should be the only child of its container.\n\n### Responsive visualizations\n\nWe can go one step beyond and not simply adjust the dimensions of the chart of the available space, but change how a dataset is being represented.\nSee the example [responsive visualizations](#/examples/charts/responsive-vis)\n\n### Custom flexible components\n\nBy using the provided flexible helpers, you can use them to make your own components flexible, like we did to create `XYPlot` flexible alternatives:\n\n```jsx\nimport {\n  XYPlot,\n  makeVisFlexible,\n  makeWidthFlexible,\n  makeHeightFlexible,\n} from 'react-vis';\n\nconst FlexibleXYPlot = makeVisFlexible(XYPlot);\nconst FlexibleWidthXYPlot = makeWidthFlexible(XYPlot);\nconst FlexibleHeightXYPlot = makeHeightFlexible(XYPlot);\n```\n","fileName":"flexible-plots.md"},{"text":"## Gradient\n\nSometimes it is useful to style our svg components using gradients. The way that this is done in React-vis is by making use of the GradientDefs component, which is a simple wrapper on the svg <defs> tag.\n\n\n\n\nSimply write gradient commands as you would normally as children of the GradientDefs component, and reference them from your series!\n\n```javascript\n<XYPlot width={300} height={300}>\n  <GradientDefs>\n    <linearGradient id=\"CoolGradient\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">\n      <stop offset=\"0%\" stopColor=\"red\" stopOpacity={0.4}/>\n      <stop offset=\"100%\" stopColor=\"blue\" stopOpacity={0.3} />\n    </linearGradient>\n  </GradientDefs>\n  <AreaSeries\n    color={'url(#CoolGradient)'}\n    data={[\n      {x: 1, y: 10, y0: 1},\n      {x: 2, y: 25, y0: 5},\n      {x: 3, y: 15, y0: 3}\n    ]}/>\n</XYPlot>\n```\n\nThis approach works with both types of gradients (Linear and circular gradients)! The biggest gotcha is that react doesn't play nice the style prop that is normally specified on the gradientTags, so it is best to specify each property directly on the component as above.\n\n\n\n\n## Component API Reference\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n","fileName":"gradients.md"},{"text":"## Cartesian Grids\n\n\n\n`VerticalGridLines` and `HorizontalGridLines` show a grid inside the chart. Here is a short example:\n\n```jsx\n<XYPlot\n  width={300}\n  height={300}>\n  <VerticalGridLines />\n  <HorizontalGridLines />\n</XYPlot>\n```\n\nCurrently both components have following properties:\n\n#### tickTotal (optional)\nType: `number`  \nTotal number of lines on the grid. Already set by default, depends on the size of the grid. Similar to the `tickTotal()` method of d3-axis.\n\n#### tickValues (optional)\nType: `Array<*>`  \nAn array of values (not coordinates!) that where the lines should be shown. Similar to the `tickValues()` method of d3-axis.\n\n#### left (optional)\nType: `number`  \nHorizontal position of the grid lines in pixels. **Already set by default**, but can be overridden by the user.\n\n#### top (optional)\nType: `number`  \nVertical position of the grid lines in pixels. **Already set by default**, but can be overridden by the user.\n\n#### width (optional)\nType: `number`  \nWidth of the grid lines in pixels. **Already set by default**, but can be overridden by the user.\n\n#### height (optional)\nType: `number`  \nHeight of the grid lines in pixels. **Already set by default**, but can be overridden by the user.\n\n#### animation (optional)\nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### style (optional)\nType: `object`\nAn CSS object that will style these gridlines. \n\n## Polar Grids\n\n\n\n`CircularGridLines` allows you to draw circular grid lines. This might be useful for a polar scatterplot, as shown above, or a radar chart or any of a wide host of additional contexts. Usage example\n\n```\n<XYPlot\n  margin={margin}\n  xDomain={[-3, 3]}\n  yDomain={[-3, 3]}\n  width={WIDTH}\n  height={HEIGHT}>\n  <CircularGridLines />\n  <XAxis top={(HEIGHT - margin.top) / 2}/>\n  <YAxis left={(WIDTH - margin.left - margin.right) / 2}/>\n  <MarkSeries\n    strokeWidth={2}\n    sizeRange={[5, 15]}\n    data={data.map(row => ({\n      ...row,\n      x: Math.cos(row.theta) * row.r,\n      y: Math.sin(row.theta) * row.r\n    }))}/>\n</XYPlot>\n```\n\nIt can often be useful to specify the x and y domains on the surrounding XYPLot. CircularGridLines accepts all of the same props as the cartesian grids, but also accepts two more:\n\n#### centerX (optional)\nType: `number`\nThe left-right value in coordinates of where the circles should be centered.\n\n#### centerY (optional)\nType: `number`  \nThe top-bottom value in coordinates of where the circles should be centered.\n\n#### rRange (optional)\nType:[`number`, `number`]\nThis allows users to specify the exact pixel range over which they wish their rings to appear.\n\n#### style (optional)\nType: `object`\nAn CSS object that will style these gridlines. See [style](style.md)\n\n","fileName":"grids.md"},{"text":"## HeatmapSeries:\n\n\n\nThe heatmap series enables users to create a 2d binning of the cartesian plane. These series often come in useful in situations when you might be using a scatterplot, but have too many rows of data for the reader to easily understand what is going on. So arises HeatmapSeries!\n\n```javascript\n<XYPlot\n  width={300}\n  height={300}>\n  <XAxis />\n  <YAxis />\n  <HeatmapSeries\n    className=\"heatmap-series-example\"\n    data={myData}/>\n</XYPlot>\n```\n\nAnother way to think of the heatmap, is as a 2D histogram, where each cell is colored by it's value rather than heighted or widthed.\n\n#### Color in heatmaps\n\nThe Heatmap's color can be manipulated in two data driven ways, first by setting the setting colorRange on the series\n\n```javascript\n<HeatmapSeries\n  className=\"heatmap-series-example\"\n  colorRange={[\"red\", \"blue\"]}\n  data={myData}/>\n```\n\nWhich assumes that each row of data has a number specifying it's color attribute. Alternatively you can change the scale type of color to allow yourself to specify color of the cell directly:\n\n```javascript\n<HeatmapSeries\n  className=\"heatmap-series-example\"\n  colorType=\"literal\"\n  data={[\n    {x: 1, y: 0, color: \"#f00\"},\n    {x: 1, y: 5, color: \"#f00\"},\n    {x: 1, y: 10, color: \"#0f0\"}\n  ]}/>\n```\n\nFinally, the color could also be specified on the series itself, however that would probably not be the best use of a heatmap as it would color every cell in the series the same color.\n\n## Data format Reference\n\nLike other series, it is required that the data be an array of objects, formatted like so:\n\n\n```javascript\nconst myData = [\n  {x: 1, y: 0, color: 10},\n  {x: 1, y: 5, color: 10},\n  {x: 1, y: 10, color: 6},\n  {x: 1, y: 15, color: 7},\n  {x: 2, y: 0, color: 12},\n  {x: 2, y: 5, color: 2},\n  {x: 2, y: 10, color: 1},\n  {x: 2, y: 15, color: 12},\n  {x: 3, y: 0, color: 9},\n  {x: 3, y: 5, color: 2},\n  {x: 3, y: 10, color: 6},\n  {x: 3, y: 15, color: 12}\n]\n```\n\nWhere x and y are required quantities and additional properties may be stapled on.\n\n#### x\nType: `number`\nThe x position in coordinates of the box to be used.\n\n#### y\nType: `number`  \nThe y position in coordinates of the box to be used.\n\n#### color (optional)\nType: `string|number`\nThe color of a box in the series. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level.\n\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### color\nType: `string|number`\nThe color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md)\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n#### fill\nType: `string|number`\nThe inner color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md)\n\n#### opacity\nType: `string|number`\nThe opacity for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### stroke\nType: `string|number`\nThe outer color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md)\n\n### style\nType: `object`\nA list of CSS properties to style the series outside of the explicitly set properties. Note that it will override all other properties (ie fill, stroke, opacity, color). See [style](style.md)\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onValueMouseOver (optional)\nType: `function(d, {event})`  \n`mouseover` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.\n\n#### onValueMouseOut (optional)\nType: `function(d, {event})`  \n`mouseout` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n\n#### onValueClick (optional)\nType: `function(d, {event})`  \n`click` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n\n","fileName":"heatmap-series.md"},{"text":"## Hint\n\n`Hint` is a simple component that shows tooltips inside the chart. `Hint` places itself to the place which is set by your data. In case a custom representation is needed, the component is also able to wrap custom JSX. Here is a short example:\n\n```jsx\n<Hint value={myValue}>\n  <div style={{background: 'black'}}>\n    <h3>Value of hint</h3>\n    <p>{myValue.x}</p>\n  </div>\n</Hint>\n```\n\nHints can be placed in two ways\na) around a data point in one of four quadrants (imagine the point bisected\n   by two axes -vertical, horizontal- creating 4 quadrants around a data\n   point).\nb) Pin to an edge of chart/plot area and position along that edge\n   using data point's other dimension value.\n\n#### value\nType: `Object`\nThe data point to show the value at. Hint component will automatically find the place where the data point is and put the hint there.\n\n#### format (optional)\nType: `function`\nFormat function for a tooltip. Receives the data point, should return an array of objects containing `title` and `value` properties. Each item of an array is shown on a separate line by default.\n_Note: please pass custom contents in case if you need different look for the hint._\n\n#### orientation (optional)\nType: `(auto|topleft|topright|bottomleft|bottomright)`\nDefault: `auto`\nThe way to align the hint inside the chart. When `auto` is set the hint is trying to stay inside the bounding box of the chart.\nSet the hint to `topleft` if you want to see a \"conventional\" hint alignment.\n\n### Style (optional)\nType: `Object`\nYou can pass a style object to your Hint component to apply your own styles. See [style](style.md)\n```jsx\n<Hint value={value} style={{fontSize: 14}}/>\n```\n\nStyle is a composite component, and individual parts of it can receive different parts.\nThe different parts are: content, row, title, value. To style a specific part, you can pass an object to the property with that name.\n```jsx\n<Hint value={value} style={{\n  fontSize: 14,\n  text: {\n    display: 'none'\n  },\n  value: {\n    color: 'red'\n  }\n}}/>\n```\n","fileName":"hint.md"},{"text":"## Interaction\n\nInteraction in react-vis happens through _event handlers_ which are triggered by certain interactive events, such as mouse movement or clicks.\n\nThese events can be implemented either at the XYPlot level or at the plot level:  \n* At the plot level: this is for events that affect the whole chart. The mouse events that can be captured are: down, enter, leave, move. For instance, you can use `onMouseLeave` to reset the visualization when the user's mouse cursor is no longer on it.\n\n* At the series level, there are three kind of handlers.\n\t* Some series (arc, bar, heatmap, label, mark, rect) support interaction at the individual mark level. These series have onValueClick, onValueMouseOut and onValueMouseOver, which, in addition to passing the event, also pass the datapoint corresponding to the mark with which the user interacted.\n    * The above series, and some others (area, line, polygon) support interaction at the series level. These series have handlers like onSeriesClick, onSeriesMouseOut, onSeriesMouseOver. Those handlers only pass the mouseevent that triggered them.\n    * Finally, all series support onNearestX and onNearestXY. These two special handlers are triggered when the user moves their mouse on the plot area, and can access the datapoint of the nearest mark, in addition to the mouse event.\n\n### What handlers are implemented by series type\n\n| Series                                | onNearestX | onNearestY | onSeriesClick | onSeriesMouseOut | onSeriesMouseOver | onValueClick | onValueMouseOut | onValueMouseOver |\n|---------------------------------------|------------|------------|---------------|------------------|-------------------|--------------|-----------------|------------------|\n| [ArcSeries](arc-series.md)            | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n| [AreaSeries](area-series.md)          | ✔︎          | ✔︎          | ✔︎             | ✔︎                | ✔︎                 |              |                 |                  |\n| [BarSeries](bar-series.md)            | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n| [ContourSeries](contour-series.md)    | ✔︎          | ✔︎          |               |                  |                   |              |                 |                  |\n| [HeatmapSeries](heatmap-series.md)    | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n| [LabelSeries](label-series.md)        | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n| [LineSeries](line-series.md)          | ✔︎          | ✔︎          | ✔︎             | ✔︎                | ✔︎                 |              |                 |                  |\n| [LineMarkSeries](line-mark-series.md) | ✔︎          | ✔︎          | ✔︎             | ✔︎                | ✔︎                 | ✔︎            | ✔︎               | ✔︎                |\n| [MarkSeries](mark-series.md)           | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n| [PolygonSeries](polygon-series.md)    | ✔︎          | ✔︎          | ✔︎             | ✔︎                | ✔︎                 |              |                 |                  |\n| [RectSeries](rect-series.md)                            | ✔︎          | ✔︎          |               |                  |                   | ✔︎            | ✔︎               | ✔︎                |\n\nHow to read this table:\nFor some series types (Arc, Bar, Rect, Label, Mark) - onValueClick, onValueMouseOut and onValueMouseOver handlers will work at the mark type. When the user clicks on the series, or moves their mouse on our out of it, an event handler will be fired and will pass the datapoint corresponding to the mark that the user interacted with.\n\nThe other series types (area, line, polygon) have an onSeriesClick, onSeriesMouseOut and onSeriesMouseOver respectively. These event handler will work at the series level and will not pass a specific datapoint.\n\nIn all cases, onNearestX and onNearestXY can be implemented at the series level, but when fired, they will also pass a specific datapoint.\n\n### Note\n- the contour series doesn't support interaction other than onNearestX or onNearestXY\n- react-vis doesn't yet support interactions such as dragging, zooming or scrolling.\n- whenever the datapoint-level handlers are supported, they can also catch all the events happening at the series level.\n\n## API\n\n### XYPlot event handlers\n\n### onMouseDown\nType: `function`  \nDefault: none  \nThis event handler is triggered whenever the mousebutton of the user is down while their mouse cursor is in the plot area. It passes a mouse event.\n\n### onMouseEnter\nType: `function`  \nDefault: none  \nThis event handler is triggered whenever the mouse of the user enters the plot area. It passes a mouse event.\n\n### onMouseLeave\nType: `function`  \nDefault: none  \nThis event handler is triggered whenever the mouse of the user exits the plot area. It passes a mouse event.\n\n### onMouseMove\nType: `function`  \nDefault: none  \nThis event handler is triggered whenever the mouse of the user moves while in the plot area. It passes a mouse event.\n\n### Series event handlers\n\n#### onNearestX\nType: `function`  \nDefault: none  \nThis handler fires when the user moves their mouse somewhere on the plot. The handler fires a function that takes two argument: the datapoint with the x value closest to the cursor, and a second object containing: the `innerX` value (x coordinates of the cursor relative to the left of the plot), `index` (position of this datapoint in the dataset, where 0 is the first datapoint, 1 is the second, etc) plus the actual event as `event`.\n\nonNearestX is at the series level, not at the plot level. If you attach onNearestX to several series, each time the user moves their mouse, each onNearestX handler will be triggered once with the closest mark of each series.\n\n```jsx\n<LineSeries\n...\n  onNearestX={(datapoint, event)=>{\n  \t// does something on mouseover\n  \t// you can access the value of the event\n  }}\n```\n\n#### onNearestXY\nType: `function`  \nDefault: none  \nThis handler is nearly identical to `onNearestX`. The difference is that it will return datapoint corresponding to the mark closest to the cursor, not just the one with the closest x coordinate.\n\nonNearestXY will supersede onNearestX, so if both exist for the same series, only onNearestXY will be fired.\n\nThis handler fires when the user moves their mouse somewhere on the plot. The handler fires a function that takes two argument: the datapoint which is closest to the cursor, and a second object containing: the `innerX` and `innerY` value (x, y coordinates of the cursor relative to the top left of the plot), `index` (position of this datapoint in the dataset, where 0 is the first datapoint, 1 is the second, etc) plus the actual event as `event`.\n\nonNearestXY is at the series level, not at the plot level. If you attach onNearestX to several series, each time the user moves their mouse, each onNearestX handler will be triggered once with the closest mark of each series.\n\n```jsx\n<LineSeries\n...\n  onNearestX={(datapoint, event)=>{\n  \t// does something on mouseover\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a series, and provides the corresponding event. Unlike onClick, it doesn't pass a specific datapoint.\n\n```jsx\n<AreaSeries\n...\n  onSeriesClick={(event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a series, and provides the corresponding event. Unlike onValueMouseOut, it doesn't pass a specific datapoint.\n\n```jsx\n<AreaSeries\n...\n  onSeriesMouseOut={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a series, and provides the corresponding event. Unlike onMouseOver, it doesn't pass a specific datapoint.\n\n```jsx\n<AreaSeries\n...\n  onSeriesMouseOver={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n\n#### onValueClick\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user clicks on a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<MarkSeries\n...\n  onValueClick={(datapoint, event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n#### onValueMouseOut\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user's mouse leaves a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<MarkSeries\n...\n  onValueMouseOut={(datapoint, event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n#### onValueMouseOver\nType: `function`\nDefault: none  \nThis handler is triggered either when the user's mouse enters a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<MarkSeries\n...\n  onValueMouseOver={(datapoint, event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n\n## Interaction strategies and examples\n\n### Interaction and hints or crosshairs\n\nThis was the first use case we built for interaction. We have one line chart on a plot, we want to show the value of the nearest mark to the cursor, without requiring the user to actually be over the plot proper.\n\n\n\n```jsx\nconst DATA = [\n  [\n    {x: 1, y: 10},\n    {x: 2, y: 7},\n    {x: 3, y: 15}\n  ],\n  [\n    {x: 1, y: 20},\n    {x: 2, y: 5},\n    {x: 3, y: 15}\n  ]\n];\n\nexport default class DynamicCrosshair extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      crosshairValues: []\n    };\n  }\n\n  render() {\n    return (\n      <XYPlot\n        onMouseLeave={() => this.setState({crosshairValues: []})}\n        width={300}\n        height={300}>\n        <VerticalGridLines />\n        <HorizontalGridLines />\n        <XAxis />\n        <YAxis />\n        <LineSeries\n          onNearestX={(value, {index}) =>\n          \tthis.setState({crosshairValues: DATA.map(d => d[index])})}\n          data={DATA[0]}/>\n        <LineSeries\n          data={DATA[1]}/>\n        <Crosshair values={this.state.crosshairValues}/>\n      </XYPlot>\n    );\n  }\n}\n```\n\nA few notes:\n- here, we are using the state to record the position of the crosshair. So, we're using the class syntax vs the React functional API.\n- We use onMouseLeave, at the plot level, to reset the visualization if the user's mouse cursor leaves the plot area.\n- There are 2 LineSeries components, but we only outfit one of them with a onNearestX handler.\n- In that handler, we get the datapoint value as first argument, and the index part of the object as 2nd argument. Actually, we only care about that index value. We're using it to generate values for the crosshair.\n- Having the handler on the 2nd LineSeries would have the exact same effect. We would change the state twice, to the same value. This is why it's not useful to call it several times.\n\n### Mousing over near scatterplot marks\n\n\n```jsx\nclass ScatterPlotOnNearestXY extends Component {\n  constructor() {\n    super();\n    this.state = {index: null};\n  }\n  render() {\n    const {index} = this.state;\n    const data = scatterPlotData.map((d, i) => ({...d, color: i === index ? 1 : 0}));\n    return <XYPlot\n      colorDomain={[0, 1]}\n      onMouseLeave={() => this.setState({index: null})}\n    >\n      <MarkSeries\n        data={data}\n        stroke=\"white\"\n        onNearestXY={(datapoint, {index}) => this.setState({index})}\n      />\n    </XYPlot>\n  }\n}\n```\n\nNotes:\n- Here, we could have used the onMouseOver prop but that would require the user to move their mouse on each dot. But those dots are small! it would be more comfortable to select whichever dot is the nearest from the cursor.\n- Again, we're going to use the state for interaction, so we use the class syntax.\n- Each time we're rendering this component, we're going to regenerate a dataset that takes the state into account. The selected datapoint will have its color property set to 1, for others it will be 0.\n- the colorDomain of XYPlot will be set to [0, 1]. This is because else, when no point is selected, the colorDomain would be [0, 0] and all dots would have the color of the higher bound (light orange).\n- As above, when the mouse leaves the plot, the state of the visualization is reset.\n- As above, in the onNearestXY handler, we're actually only interested in the index part of the second argument.\n\n### Mousing over series - the 2nd series group option\n\n```jsx\nclass LineChartMouseOverSeries extends Component {\n  constructor() {\n    super();\n    this.state = {index: null};\n  }\n  render() {\n    const {index} = this.state;\n    return <XYPlot {...defaultProps}\n        onMouseLeave={() => this.setState({index: null})}\n      >\n      {lineData.map((d, i) => (<LineSeries\n        data={d} key={`${i}`} stroke={i === index ? \"orange\" : undefined}\n      />))}\n      {lineData.map((d, i) => (<LineSeries\n        data={d} key={`${i}-mouseover`}\n        onSeriesMouseOut={() => this.setState({index: null})}\n        onSeriesMouseOver={() => this.setState({index: i})}\n        strokeWidth={10} stroke=\"transparent\"}\n      />))}\n    </XYPlot>\n  }\n}\n```\nHere, we are going to explore 2 strategies to handle highlighting one line series among several on screen.  \nWe could do that with a simple onSeriesMouseOver but, again, that would require mousing over exactly on a line series, which are notoriously narrow.\nInstead, we create a second set of LineSeries whose only purpose is to handle interaction. That second set of LineSeries is thicker (here, the stroke width is set at a generous 10px) and is also transparent. In the embedded example, I'm highlighting each lineSeries as it is moused over, but I'm not reflecting this on the snippet of code.\n\nHere, lineData is an array of arrays. The LineSeries are created by mapping over that array, which is quite common.\nWhen creating the LineSeries for mouseover, I write:\n\n```jsx\n{lineData.map((d, i) => (<LineSeries\n  ...\n  onSeriesMouseOver={() => this.setState({index: i})}\n```\n\nIn the onSeriesMouseOver handler, I don't pass any argument in the handler proper, but I'm using the index of the array from the mapping method. So, for the first LineSeries, that value is 0, then 1, then 2.\n\n### Mousing over series - the extra scatterplot option\n\n```jsx\nconst allData = lineData.reduce((prev, curr, i) => {\n  return [...prev, ...curr.map((d) => ({...d, index: i}))]\n}, []);\n\nclass LineChartMouseOverXY extends Component {\n  constructor() {\n    super();\n    this.state = {index: null};\n  }\n  render() {\n    const {index} = this.state;\n\n    return <XYPlot {...defaultProps}\n        onMouseLeave={() => this.setState({\n          highlightedSeries: null,\n          pointUsed: null\n        })}\n      >\n      {lineData.map((d, i) => (<LineSeries\n        data={d} key={`${i}`} stroke={i === index ? \"orange\" : undefined}\n      />))}\n      <MarkSeries\n        data={allData}\n        color=\"transparent\"\n        size={10}\n        onNearestXY={({index}) => this.setState({index})}\n      />\n    </XYPlot>\n  }\n}\n```\nHere's a slightly different strategy to obtain a similar effect.\nPrior to rendering this component, I've created an \"allData\" dataset which is a flat array of all the datapoints in the 3 lineSeries' datasets, only we've added to each of these datapoints an extra property, index, which will be 0, 1 or 2 depending from which of the 3 dataset each datapoint comes.\n\nSo allData will be an array of objects of the form: {x: ..., y: ..., index: ...}. Index, the last property, will be ignored by scales and won't affect the rendering in any way.\n\nThen, on top of our 3 lineSeries, we're adding a MarkSeries with an onNearestXY handler, just as 2 examples above.\n\nThe first argument of the onNearestXY handler is the datapoint proper. So again: an object of the form: {x:... ,y:..., index:...}. While the index property was not taken into account for rendering, it is definitely part of the first argument. Actually, it's the only part that we care about, so we just write ({index}) =>.\n\nIn the embedded version of this example, I'm highlighting the mark that triggers onNearestXY, however I haven't added this in the snippet of code above.\n\n### Linked Charts\n\n\n```jsx\nclass LinkedCharts extends Component {\n  constructor() {\n    super();\n    this.state = {index: null};\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  handleMouseOver(index) {\n    this.setState({index});\n  }\n  render() {\n    const {index} = this.state;\n    return (<div style={{display: 'flex'}}>\n      {lineData.map((d, i) => (<div key={i}>\n        <LineChart\n          data={d}\n          index={index}\n          handleMouseOver={this.handleMouseOver} />\n        </div>))}\n    </div>);\n  }\n}\n\nfunction LineChart({data, index, handleMouseOver}) {\n  return (<XYPlot\n    yDomain={[0, 10]}\n    onMouseLeave={() => handleMouseOver(null)}\n    >\n      <LineSeries\n        data={data}\n        onNearestX={(datapoint, {index}) => handleMouseOver(index)} />\n      {index === null ? null : <LineSeries\n        data={[{x: index, y: 0}, {x: index, y: 10}]}\n        opacity={0.5} />\n      }\n      {index === null ? null : <MarkSeries\n        data={[data[index]}]}\n        stroke=\"white\" />\n      }\n    </XYPlot>);\n}```\n\nMore often than not, you want to be able to handle an action that happened in one of the charts and reflect it in different parts of your app, i.e. outside the chart.\n\nThis is a common React problem, and we're going to deal with it in a proven React way - with a container that has a state, and which will pass this state and actions to presentation components.\n\nThese presentation components will be represented according to the state of that container, and will be able to fire actions that will impact it.\n\nOur container is a simple class. We create this method, handleMouseOver, that we'll have to bind to the container because we're going to pass it down. When we're doing that, we'll want that method to affect the state of the container.\n\nOur container will create three \"LineChart\" components, to which it will pass the dataset of a line (i.e. an array of {x, y} objects, the contents of the state - which is simply an index value, if there has been a mouseOver action, or null if there hasn't been - and our handleMouseOver method.\n\nInside the LineChart components, we'll use onMouseLeave and onNearestX to trigger the handler, as in the examples above. So, if the user mouses over any of these line charts, this changes the state of the container above, which will trickle down to all 3 components again.\n\nFinally, we create a dynamic line and dot gizmo to represent where the user is mousing over. We can easily generate a dataset for that, since index is the x value of where both the line and the dot should be.\n","fileName":"interaction.md"},{"text":"## react-vis\n\nreact-vis is a charting library for React. \n\nIt is: \n\n* __Expressive__: react-vis supports a large number of types of charts, from area charts to treemaps, as well as many charting elements like axes or tooltips. \n* __High-level__: react-vis is optimized for making charts with the least amount of code. It lets user access high-level components rather than force them to control every pixel,\n* __Deeply customizable__: react-vis charts have sensible defaults, yet everything can be changed. \n* __Consistent with React__: a chart in react-vis is made of components which have properties and children, just like traditional react,\n* __Industry-strong__: react-vis was created to support the many internal tools of Uber.\n","fileName":"introduction.md"},{"text":"## LabelSeries:\n\n\n\nSometimes you just need to write on your data, and labelSeries has your back. This simple series has a similar API as the markSeries except it adds a label property to each of the rows. This label is then rendered as part of the svg tree.\n\n```javascript\n<XYPlot width={300} height={300}>\n  <LabelSeries\n    animation\n    allowOffsetToBeReversed\n    data={data} />\n</XYPlot>\n```\nThis can be useful for annotating points, as above, or in labeling wedges as (as in the radial chart).\n\n## Data format Reference\n\nLike other series the `labelSeries` requires the data be formatted as an array of objects with several required keys and several options ones. Here's an example\n\n\n```javascript\nconst myData = [\n  {x: 0, y: 0, label: 'woah!', style={fontSize: 10}},\n  {x: 1, y: 0, label: 'dope city', yOffset: 5},\n  {x: 0, y: 1, label: 'cool Dog friend', xOffset: 5, rotation: 34}\n]\n```\n\nThe above would render three points with labels as suggested!\n\n#### x\nType: `number`\nThe x position in coordinates of the label.\n\n#### y\nType: `number`  \nThe y position in coordinates of the label.\n\n#### label\nType: `string`\nThe actual text to be offered.\n\n#### xOffset\nType: `number`\nA number in pixels for the label to be offset from the x position specified on the row.\n\n#### yOffset\nType: `number`\nA number in pixels for the label to be offset from the y position specified on the row.\n\n#### rotation\nType: `number`\nNumber in degrees for the text to be rotated about its xy point.\n\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n### allowOffsetToBeReversed (optional)\nThe allows the offset specified on the data rows to flipped if the label is too close to an edge. This allows you to make sure your labels never get randomly clipped by going offscreen.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n#### style\nType: `object`\nSVG text objects (which is what the labelSeries is made up of) accept a ton of different styles, so rather than prescribe every single one we just accept a general grab bag pf the styles. check out the [w3](https://www.w3schools.com/graphics/svg_path.asp) page for more details.\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onValueMouseOver (optional)\nType: `function(d, {event})`  \n`mouseover` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.\n\n#### onValueMouseOut (optional)\nType: `function(d, {event})`  \n`mouseout` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n\n#### onValueClick (optional)\nType: `function(d, {event})`  \n`click` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n","fileName":"label-series.md"},{"text":"## Legends\n\n\n\nCurrently following types of legends are supported:\n\n- for colors:\n  * DiscreteColorLegend (for a fixed number of colors, good for series);\n  * SearchableDiscreteColorLegend) (same as DiscreteColorLegend, but with search on top);\n  * ContinuousColorLegend (for gradually changing colors);\n- for sizes:\n  * ContinuousSizeLegend (for gradually changing size).\n\n## Color legends\n\n### DiscreteColorLegend\n\n\n\n#### items (required)\nType: `Array<string|{title: string, color: String, disabled: boolean}>`  \nArray of items that should be shown on the legend. The array should consist from either objects (`title`, optional `color` and optional `disabled` flag) or strings (treated as titles).\n\n#### onItemClick\nType: `function(Object, number): void`  \nClick callback for the item in the list. Gets the clicked item and its index as parameters.\n\n#### width\nType: `number`  \nOuter width of the component. Default width is not set.\n\n#### height\nType: `number`  \nOuter height of the component. Default is not set, the component stretches with the items added into it.\n\n### SearchableDiscreteColorLegend\n\n`SearchableDiscreteColorLegend` allows the user to perform search among the items.\n\n\n\nIts API includes the API of `DiscreteColorLegend`, but adds several search-related items:\n\n#### searchText (optional)\nType: `string`  \nDefault: `''`  \n\n#### searchFn (optional)\nType: `function(Array, string):Array`  \nFunction that is should filter out the unnecessary items by the given initial array of items and the search string. By default the function returns an array of items which titles contain a string.\n\n#### searchPlaceholder (optional)\nType: `string`  \nDefault: `''`  \nPlaceholder for an search input field.\n\n#### onSearchChange (optional)\nType: `function(string):void`  \nEvent handler for the change of the input field. The handler is triggered with the search field value as a parameter.\n\n### ContinuousColorLegend\n\n\n\n#### startTitle\nType: `string|number`  \nThe title that is shown in the beginning of the legend.\n\n#### midTitle\nType: `string|number`  \nThe title that is show in the middle of the legend.\n\n#### endTitle\nType: `string|number`  \nThe title that is show in the end of the legend.\n\n#### startColor (optional)\nType: `string`     \nThe initial color of the bar\n\n#### endColor (optional)\nType: `string`    \nThe end color of the bar.\n\n#### midColor (optional)\nType: `string`    \nThe middle color of the bar.\n\n#### width (optional)\nType: `number`\nOuter width of the component.\n\n#### height (optional)\nType: `number`  \nOuter height of the component.\n\n## Size Legends\n\n### ContinuousSizeLegend\n\n\n\n#### startTitle\nType: `string|number`  \nThe title that is shown in the beginning of the legend.\n\n#### endTitle\nType: `string|number`  \nThe title that is show in the end of the legend.\n\n#### startSize (optional)\nType: `number`  \nDefault: `2`   \nThe initial size of the circles in the legend.\n\n#### endSize (optional)\nType: `number`  \nDefault: `20`  \nThe end size of the circles in the legend.\n\n#### circlesTotal (optional)\nType: `number`  \nDefault: `10`  \nTotal amount of circles displayed in the legend\n\n#### width (optional)\nType: `number`\nOuter width of the component.\n\n#### height (optional)\nType: `number`  \nOuter height of the component.\n","fileName":"legends.md"},{"text":"# LineMarkSeries\n\nThe Line Mark series is a combination of a LineSeries and a MarkSeries: under the hood, it creates both a LineSeries and a MarkSeries and passes them all of its properties.\n\n\n\n## Data format reference\n\n#### x\nType: `string|number|date`  \nx will be used to determine the x position of each point on the line. The format of x depends on what scale is being used - see [Scales and Data](scales-and-data.md)\n\n#### y\nType: `string|number|date`\ny will be used to determine the y position of each point on the line. The format of y depends on what scale is being used - see [Scales and Data](scales-and-data.md)\n\n#### color (optional)\nType: `string|number`\nThe color of the line and that of the marks. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level.\n\n#### opacity (optional)\nType: `string|number`  \nOpacity of the individual box to be rendered. By default opacity is scaled by `literal`, so the exact value provided will be used. This property can also be defined on the series level.\n\n#### stroke (optional)\nType: `string|number`  \nStroke affects both the color of the line, and the outline of the marks. When this value is not provided, the color attribute is used instead. This property can also be defined on the series level.\n\n#### fill (optional)\nType: `string|number`  \nThe color of the inside of the marks. When this value is not provided the color attribute is used instead. This property can also be defined on the series level.\n\n#### size (optional)\nType: `string|number`  \nDefault: 5\nThe size of each of the marks.\n\n## API Reference\n\n#### curve (optional)\nType: `string|function`\nDefault: `null`\nApply the provided or named curve function from the D3 shape library to smooth the line series plot, see [the D3 documentation](https://github.com/d3/d3-shape#curves) for function names and instructions. Providing the function, not the name, will require importing the d3-shape package in order to configure it:\n\n```javascript\n// Setting up with only a name\nconst stringCurveProp = <LineMarkSeries data={data} curve={'curveMonotoneX'} .../>;\n\nconst configuredCurve = d3Shape.curveCatmullRom.alpha(0.5);\nconst funcCurveProp = <LineMarkSeries data={data} curve={configuredCurve} .../>;\n```\n\nSome, but not all line interpolations have the resulting curve going through the original coordinates of its data points. If not, the LineSeries part of the LineMarkSeries will be detached from the MarkSeries part.\n\n#### fill (optional)\nType: `string|number`\nThe inner color for all the marks in the series, this property will be over-ridden by fill specified in the data attribute. See [colors](colors.md)\n\n#### stroke (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)  \nA color for the series. Will override color if both are provided.\n\n##### strokeDasharray (optional)\nType: `string`\nSpecify a custom `stroke-dasharray` attribute which controls the pattern of dashes and gaps used to stroke paths. This will only affect the LineSeries part of the LineMarkSeries.\n\n##### strokeStyle (optional)\nType: `string`\nIf set to `dashed`, your series will use dashed lines. If set to `solid` or unspecified, your series will use solid lines. See `strokeDasharray` for specifying a custom stroke dash-array value. This will only affect the LineSeries part of the LineMarkSeries.\n\n##### strokeWidth (optional)\nType: `string|number`\nSpecifies the width of the line for the series. By default, this is determined by react-vis css (2px). This will affect both the thickness of the Line and the Marks.\n\n#### style (optional)\nType: `object`\nAn object which holds CSS properties that will be applied to the SVG element(s) rendered by the series. See [style](style.md)This allows you to style series beyond the other explicitly defined properties and without having to use CSS classnames and stylesheets.\n\n```jsx\n<LineMarkSeries\n  data={data}\n  style={{strokeLinejoin: \"round\"}}\n/>\n```\n\n`LineMarkSeries` being a composite component (a mix of [LineSeries](line-series.md) and [MarkSeries](mark-series.md)), there are two additional property in the `style` object: `line` and `mark`, which allow you to specify a style for the line or the mark part of the line mark series, respectively.\n\n```jsx\n<LineMarkSeries\n  data={data}\n  style={{line: {stroke:\"blue\"}, mark: {stroke:\"red\"}}}\n/>\n```\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a series, and provides the corresponding event. Unlike onClick, it doesn't pass a specific datapoint.\n\n```jsx\n<LineMarkSeries\n...\n  onSeriesClick={(event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a series, and provides the corresponding event. Unlike onValueMouseOut, it doesn't pass a specific datapoint.\n\n```jsx\n<LineMarkSeries\n...\n  onSeriesMouseOut={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a series, and provides the corresponding event. Unlike onValueMouseOver, it doesn't pass a specific datapoint.\n\n```jsx\n<LineMarkSeries\n...\n  onSeriesMouseOver={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onValueClick\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user clicks on a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<LineMarkSeries\n...\n  onValueClick={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOut\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user's mouse leaves a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<LineMarkSeries\n...\n  onValueMouseOut={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOver\nType: `function`\nDefault: none  \nThis handler is triggered either when the user's mouse enters a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<LineMarkSeries\n...\n  onValueMouseOver={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n","fileName":"line-mark-series.md"},{"text":"# LineSeries/LineMarkSeries\n\n\n\nreact-vis offers two different types of LineSeries, one that renders SVG and one that renders Canvas.\nThe SVG mode is accessed by using the normal `LineSeries`, just as above, while the Canvas mode is used by simply calling `LineSeriesCanvas` instead of `LineSeries`.\n\n\n-**NOTE**: using the Canvas version of this layer disables animation\n\n## Data format reference\n\n#### x\nType: `number`  \nLeft-to-right position of marks in the series.\n\n#### y\nType: `number`  \nTop-to-bottom position of the top edge of the series.\n\n## API Reference\n\n#### color (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)\nColor of the line series. \nBy default, you can pass a literal color to the series (i.e. \"red\" or \"#f70\"). You can also define a color scale at the top level, and pass a number which will be interpolated by the scale. If nothing is provided, lineSeries will be colored according to react-vis default scale.\n\n#### curve (optional)\nType: `string|function`\nDefault: `null`\nApply the provided or named curve function from the D3 shape library to smooth the line series plot, see [the D3 documentation](https://github.com/d3/d3-shape#curves) for function names and instructions. Providing the function, not the name, will require importing the d3-shape package in order to configure it:\n\n```javascript\n// Setting up with only a name\nconst stringCurveProp = <LineSeries data={data} curve={'curveMonotoneX'} .../>;\n\nconst configuredCurve = d3Shape.curveCatmullRom.alpha(0.5);\nconst funcCurveProp = <LineSeries data={data} curve={configuredCurve} .../>;\n```\n\n#### data\nType: `Array<Object>`  \nArray of data for the series. See above data format reference.\n\n#### opacity (optional)\nType: `number`  \nDefault: 1  \nOpacity of the area chart from 0 (transparent) to 1 (opaque).\n\n#### stroke (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)  \nA color for the series. Will override color if both are provided.\n\n##### strokeDasharray (optional)\nType: `string`\nSpecify a custom `stroke-dasharray` attribute which controls the pattern of dashes and gaps used to stroke paths.\n\n##### strokeStyle (optional)\nType: `string`\nIf set to `dashed`, your series will use dashed lines. If set to `solid` or unspecified, your series will use solid lines. See `strokeDasharray` for specifying a custom stroke dash-array value.\n\n##### strokeWidth (optional)\nType: `string|number`\nSpecifies the width of the line for the series. By default, this is determined by react-vis css (2px).\n\n#### style (optional)\nType: `object`\nAn object which holds CSS properties that will be applied to the SVG element(s) rendered by the series. This allows you to style series beyond the other explicitly defined properties and without having to use CSS classnames and stylesheets. See [style](style.md)\n\n```jsx\n<LineSeries\n  data={data}\n  style={{strokeLinejoin: \"round\"}}\n/>\n```\n\n### Interaction handlers\n\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a LineSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\n<LineSeries\n...\n  onSeriesClick={(event)=>{\n  \t// does something on click\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a LineSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\nLineSeries\n...\n  onSeriesMouseOut={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a LineSeries, and provides the corresponding event. See [interaction](interaction.nd)\n\n```jsx\n<LineSeries\n...\n  onSeriesMouseOver={(event)=>{\n  \t// does something on mouse over\n  \t// you can access the value of the event\n  }}\n```\n","fileName":"line-series.md"},{"text":"## MarkSeries & MarkSeriesCanvas\n\n\n\nThe Markseries allows users to embed discrete information in pairs of continuous variables,\nthat is make scatterplots. Deploying a markseries is super easy:\n\n```javascript\nrender() {\n  return (\n    <XYPlot\n      width={300}\n      height={300}>\n      <MarkSeries\n        className=\"mark-series-example\"\n        sizeRange={[5, 15]}\n        data={myData}/>\n    </XYPlot>\n  );\n```\n\nJust like other series, MarkSeries expects its data to be formatted as an array of objects, like so:\n\n```javascript\nconst myData = [\n  {x: 1, y: 10, size: 30},\n  {x: 1.7, y: 12, size: 10},\n  {x: 2, y: 5, size: 1},\n  {x: 3, y: 15, size: 12},\n  {x: 2.5, y: 7, size: 4}\n]\n```\n\nreact-vis offers two different types of MarkSeries, one that renders SVG and one that renders Canvas.\nThe SVG mode is accessed by using the normal `MarkSeries`, just as above, while the Canvas mode is used by simply calling `MarkSeriesCanvas` instead of `MarkSeries`.\n\n\n\n-**NOTE**: using the Canvas version of this layer disables animation\n\n## Data format reference\n\n#### x\nType: `string|number|date`  \nx will be used to determine the x position of each mark. The format of x depends on what scale is being used - see [Scales and Data](scales-and-data.md)\n\n#### y\nType: `string|number|date`\ny will be used to determine the y position of each mark. The format of y depends on what scale is being used - see [Scales and Data](scales-and-data.md)\n\n#### color (optional)\nType: `string|number`\nThe color of the marks. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level.\n\n#### opacity (optional)\nType: `string|number`  \nDefault: 1  \nOpacity of the individual marks, from 0 (transparent) to 1 (opaque). By default opacity is scaled by `literal`, so the exact value provided will be used. This property can also be defined on the series level.\n\n#### stroke (optional)\nType: `string|number`  \nThe color of the outline of the marks. When this value is not provided, the color attribute is used instead. This property can also be defined on the series level.\n\n#### fill (optional)\nType: `string|number`  \nThe color of the inside of the marks. When this value is not provided the color attribute is used instead. This property can also be defined on the series level.\n\n#### size (optional)\nType: `string|number`  \nDefault: 5\nThe size of each of the marks.\n\n## API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### color (optional)\nType: `string|number`\nExact color for all series points or a series object.\n\n#### data\nType: `Array<Object>`\nArray of data for the series.\n\n#### fill (optional)\nType: `string|number`\nThe inner color for all the marks in the series, this property will be over-ridden by fill specified in the data attribute. See [colors](colors.md)\n\n#### opacity (optional)\nType: `string|number`  \nExact opacity for all series points in pixels or a series object, from 0 (transparent) to 1 (opaque)\n\n#### size (optional)\nType: `string|number`  \nExact size for all series points in pixels or a series object.\n\n#### stroke (optional)\nType: `string|number`  \nDefault: see [colors](colors.md)  \nA color for the outline of the marks. Will override color if both are provided.\n\n#### strokeWidth (optional)\nType: `string|number`\nDefault: 1\nThe width of the outline of the marks.\n\n## Interaction handlers\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onSeriesClick\nType: `function`  \nDefault: none  \nThis handler fires when the user clicks somewhere on a series, and provides the corresponding event. Unlike onClick, it doesn't pass a specific datapoint.\n\n```jsx\n<MarkSeries\n...\n  onSeriesClick={(event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOut\nType: `function`  \nDefault: none  \nThis handler fires when the user's mouse cursor leaves a series, and provides the corresponding event. Unlike onValueMouseOut, it doesn't pass a specific datapoint.\n\n```jsx\n<MarkSeries\n...\n  onSeriesMouseOut={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onSeriesMouseOver\nType: `function`\nDefault: none  \nThis handler fires when the user mouses over a series, and provides the corresponding event. Unlike onValueMouseOver, it doesn't pass a specific datapoint.\n\n```jsx\n<MarkSeries\n...\n  onSeriesMouseOver={(event)=>{\n    // does something on mouse over\n    // you can access the value of the event\n  }}\n```\n\n#### onValueClick\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user clicks on a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<MarkSeries\n...\n  onValueClick={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOut\nType: `function`  \nDefault: none  \nThis handler is triggered either when the user's mouse leaves a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<MarkSeries\n...\n  onValueMouseOut={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n\n#### onValueMouseOver\nType: `function`\nDefault: none  \nThis handler is triggered either when the user's mouse enters a mark.\nThe handler passes two arguments, the corresponding datapoint and the actual event.\n```jsx\n<BarSeries\n...\n  onValueMouseOver={(datapoint, event)=>{\n    // does something on click\n    // you can access the value of the event\n  }}\n```\n","fileName":"mark-series.md"},{"text":"## PolygonSeries:\n\n\n\nThe polygon series allows users to specify arbitrary polygons in coordinates. This may seem un-useful, but it allows for\neasy creation of radar charts, fancy mark series dots, and any variety of additional things you might need polygons for!\n\n```javascript\n<XYPlot\n  width={300}\n  height={300}>\n  <XAxis />\n  <YAxis />\n  <PolygonSeries\n    className=\"polygon-series-example\"\n    data={myData}/>\n</XYPlot>\n```\n\nEach series corresponds to exactly **one** svg path. It is perfectly okay to many series to express many polygons!\n\n## Data format Reference\n\nLike other series, it is required that the data be an array of objects, formatted like so:\n\n\n```javascript\nconst myData = [\n  {x: 0, y: 0},\n  {x: 1, y: 0},\n  {x: 0, y: 1}\n]\n```\n\nWhich would render a triangle.\n\n#### x\nType: `number`\nThe x position in coordinates of the box to be used.\n\n#### y\nType: `number`  \nThe y position in coordinates of the box to be used.\n\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### color\nType: `string`\nThe color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md)\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n#### style\nType: `object`\nPaths accept a ton of different styles, so rather than prescribe every single one we just accept a general grab bag pf the styles. check out the [w3](https://www.w3schools.com/graphics/svg_path.asp) page for more details and the [style] documnetation (style.md).\n\n## Interaction handlers\n\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onSeriesMouseOver (optional)\nType: `function(d, {event})`  \n`mouseover` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property. See [interaction](interaction.md)\n\n#### onSeriesMouseOut (optional)\nType: `function(d, {event})`  \n`mouseout` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property. See [interaction](interaction.md)\n\n#### onSeriesClick (optional)\nType: `function(d, {event})`  \n`click` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property. See [interaction](interaction.md)\n\n","fileName":"polygon-series.md"},{"text":"# Radar Charts\n\nRadar charts provide a cute method for displaying many variables simultaneously. It allows for rapid at-a-glance comparisons across a bunch of dimensions. These graphics can effectively be used either with several data rows on a single chart (as below) or as a small multiple. For more information, check out the [Wiki](https://en.wikipedia.org/wiki/Radar_chart), it's got some really neat examples.\n\n\n\nImagine you have a trio of models of cars that you are trying to compare. You're being data driven so you've collected a number of measurements based on a variety of values. You know basic facts about your variables, eg the interior rating a car can have is 7 and the minimum 1. You can use all this information to produce the above chart! Viola! Informed consumer.\n\n\n\nJust like every other chart and series RadarChart expects an array of data, each row or object corresponds to a line or polygon (depending on how you have your chart styled). A key caveat for this chart type is that react-vis can not simply infer the variables from each data object that you wish to plot, so we need you to tell us! So enters the domains prop, an array of object specifying the order and behavior of each of the variables. So you have to tell react-vis a little more to get started, but you get a lot more expressiveness. Let's consider some code. You might provide the following object as props to the radar chart:\n\n```javascript\nconst RADAR_PROPS = {\n  data: [{\n    explosions: 7,\n    wow: 10,\n    dog: 8,\n    sickMoves: 9,\n    nice: 7\n  }],\n  domains: [\n    {name: 'nice', domain: [0, 100]},\n    {name: 'explosions', domain: [6.9, 7.1]},\n    {name: 'wow', domain: [0, 11]},\n    {name: 'sickMoves', domain: [0, 20]}\n  ],\n  height: 300,\n  width: 400\n};\n```\n\nIn such a case, there would be ONE polygon rendered for four variables (nice/explosions/wow/sickMoves), because those values are listed in the domains prop. The radar chart accepts children if you wish to provide additional components, such as CircularGridLines.\n\n\n## API Reference\n\n\n#### data\nType: `arrayOf(Objects)`\n\n#### domains\nType: `arrayOf(Objects)`\nThe domains allow the user to specify the nature of the variables being plotted. This information is captured in an object formatted like:\n\n```javascript\nPropTypes.shape({\n  name: PropTypes.string.isRequired,\n  domain: PropTypes.arrayOf([PropTypes.number]).isRequired,\n  tickFormat: PropTypes.func\n})\n```\n\nLet's looks at each member of the object\n\n- name: generates a member of a labelSeries that shows at the end of the corresponding axis\n- domain: a pair of numbers that are interpolated between. Setting these values correctly is essential for making your graphic legible! Because it is often the case that there will only be one or two data rows in a radar chart, react-vis requires the user to specify the exact domain for each variable. Without which we would be unable to plot the variables well.\n- tickFormat: allows the user to provide a formatting function for prettifiying the the way that axis interpolates between the domain values.\n\n#### width\nType: `number`  \nWidth of the component.\n\n#### height\nType: `number`  \nHeight of the component.\n\n#### margin (optional)\nType: `Object`  \nDefault: `{left: 40, right: 10, top: 10, bottom: 40}`\nMargin around the chart.\n\n### style (optional)\nType: `object`\nAn object that contains CSS properties with which the axis component can be entirely re-styled.\nAs the RadarChart is composite of several composite elements, it is possible to provide style objects for any and all parts of the tree. See [style](style.md)\nMost generally, there are three top level components `axes`, `labels`, and `polygons`. These in turn lead to their corresponding to style objects. As an example, here is the default style object for the RadarChart:\n\n```jsx\n<RadarChart data={mydata} style={{\n  axes: {\n    line: {},\n    ticks: {},\n    text: {}\n  },\n  labels: {\n    fontSize: 10\n  },\n  polygons: {\n    strokeWidth: 0.5,\n    strokeOpacity: 1,\n    fillOpacity: 0.1\n  }\n}}/>\n```\n\n#### animation (optional)\nType: `boolean|Object`\nPlease refer to [Animation](animation.md) doc for more information.\n\n#### hideInnerMostValues (optional)\nType: `boolean`\ndefaults to true\nWhether or not to hide the inner most tick values of the radar chart. This attempts to ensure that the ticks do not run over each other.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### colorType (optional)\nType: `string`\nSpecify the type of color scale to be used on the radar chart, please refer to [Scales and data](scales-and-data.md) for more information.\n\n#### tickFormat (optional)\nType: 'function'\nSpecify the tick format for all axes. Will be over-ridden by tickFormats specified on single domains.\n\n#### startingAngle (optional)\nType: `number`\nThe angle of the first axis in radians. Defaults to PI / 2.\n","fileName":"radar-chart.md"},{"text":"# Radial chart\n\n`RadialChart` is responsible for creating pie and donut charts. While this kind of chart is easy to overlook as insignificant, intentionally confusing, or almost always replaceable with a treemap; they can be useful for quickly showing small groups. People don't understand angles very well [(such is our biology)](https://www.interaction-design.org/literature/book/the-encyclopedia-of-human-computer-interaction-2nd-ed/data-visualization-for-human-perception), but over the last hundred years we have seen a lot of pie charts! This has caused us to become intimately familiar with them.\n\n\n\nWe can leverage this familiarity to quickly transmit information to our reader. The best type of information to display in this way (in our opinion) is groups of less 6 or so. More than that becomes pretty hard to compare and the reader just sees visual noise. The radial chart is easy to deploy:\n\n```jsx\n\n<RadialChart\n  data={myData}\n  width={300}\n  height={300} />\n```\n\nThe radial chart accepts children if you wish to give it them. This can be useful for adding tooltips, for example:\n\n\n\n\n## Data format Reference\n\n\nRadial chart has a very similar API to the arc series, but with even fewer requirements. To wit the data can be as simple as\n\n\n```javascript\nconst myData = [{angle: 1}, {angle: 5}, {angle: 2}]\n```\n\nOr as complex as\n\n[\n  {angle: 1, radius: 10},\n  {angle: 2, label: 'Super Custom label', subLabel: 'With annotation', radius: 20},\n  {angle: 5, radius: 5, label: 'Alt Label'},\n  {angle: 3, radius: 14},\n  {angle: 5, radius: 12, subLabel: 'Sub Label only', className: 'custom-class'}\n];\n\n#### angle\nType: `number`\nThe only required property for the data, this determines the angular size of each wedge.\n\n#### radius\nType: `number`\nThe distance between the origin and the outside of the arc. This values is scaled linearly by default\n\n#### label\nType: `string`\nThe label to show next to the wedge.\n\n#### subLabel\nType: `string`\nThe subLabel to show next to the wedge. This can be used for annotations to the top label.\n\n#### color (optional)\nType: `string|number`\nThe color of a box in the series. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level.\n\n#### style (optional)\nType: `object`\nSVG paths (which is what the arc series is made up of) have numerous manipulable properties, so rather than trying to prescribe all of them as props we offer a port to let you style it for yourself. This overrides the series level version of this property.\n\n#### className (optional)\nType: `string`\nThe className to be added to an individual arc in the series.\n\n## Api\n\n##### angleDomain, angleRange, angleType\n\nScale properties for the `angle` scale. The `angle` property _should be_ passed in the data, otherwise the chart won't be shown.\nPlease refer to [Scales and Data](scales-and-data.md) for more information about scales.\n\n##### animation (optional)\nType: `boolean|Object`\nPlease refer to [Animation](animation.md) doc for more information.\n\n##### className (optional)\n\nType: `string`\nDOM classNames to be added to the wrapper component.\n\n##### colorDomain, colorRange, colorType\n\nScale properties for the `color` scale. If `color` property is not passed in the data object, each new section of the chart gets the next color (e. g. the `'category'` scale is applied).\nPlease refer to [Scales and Data](scales-and-data.md) for more information about scales.\n\n##### data\n\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n##### fillDomain, fillRange, fillType\n\nScale properties for the `fill` scale. If `fill` property is not passed in the data object, color scale is used instead.\nPlease refer to [Scales and Data](scales-and-data.md) for more information about scales.\n\n##### height (required, pixels)\n\n#### innerRadius\nType: `number` in pixels\nIf radius is not set on the data then this can be used to set the innerRadius for all of the rows. This can be useful for building donut charts.\n\n##### width (required, pixels)\n\n#### labelsAboveChildren\nType: `boolean`\nWhether or not to position the labels on top of the children. This can be useful if you have circular gridline and you want your labels to be legible on top of your grids.\n\n##### margin (optional, pixels)\nType: `Object`\nDefault: `{left: 40, right: 40, top: 10, bottom: 10}`\n\n#### radius\nType: `number` in pixels\nIf radius is not set on the data then this can be used to set the radius for all of the rows.\n\n##### showLabels (optional)\nType: `boolean`\nWhether or not to show the labels specified in the data\n\n##### strokeDomain, strokeRange, strokeType\n\nScale properties for the `stroke` scale. If `stroke` property is not passed in the data object, stroke is _not_ visualized.\nPlease refer to [Scales and Data](scales-and-data.md) for more information about scales.\n","fileName":"radial-chart.md"},{"text":"# Rect Series\n\nRectSeries is a generalization of [BarSeries](bar-series.md) which allows users to build a series of rectangles of arbitrary dimensions. Whereas in barSeries, one dimension of the bars is fixed (width for vertical bar series, height for horizontal bar series), in RectSeries, both dimensions can be controlled. \n\nRectSeries can be used to build histograms, icicle charts, or anything really where both height and width matter. \n\n\n\n\n\nLike BarSeries, RectSeries has two wrappers: HorizontalRectSeries and VerticalRectSeries. It also has a canvas version, RectSeriesCanvas (along with HorizontalRectSeriesCanvas and VerticalRectSeriesCanvas).\n\nRectSeries isn't meant to be used directly, however, it's provided as it's being used under the hood by HorizontalRectSeries and VerticalRectSeries. \n\n## Data format Reference\n\nLike other series, it is required that the data be an array of objects, formatted like so:\n\n```javascript\nconst myData = [\n  {x: 0, x0: 1, y: 10, y0: 0},\n  {x: 1, x0: 2, y: 5, y0: 0},\n  {x: 2, x0: 4, y: 15, y0: 0}\n]\n```\n\nThe main difference with bar series is that it has x0 and y0 properties.  \n\n### For HorizontalRectSeries:\n\n#### x (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the x position of _either_ side of the rectangle.\n\n#### x0 (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the x position of the other side of the rectangle.\n\n#### y (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the y position of _the bottom_ of the rectangle.\n\n#### y0 (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the y position of _the top_ of the rectangle.\n\n### For VerticalRectSeries:\n\n#### x (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the x position of _the left_ side of the rectangle.\n\n#### x0 (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the x position of _the right_ side of the rectangle.\n\n#### y (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the y position of _either_ side of the rectangle.\n\n#### y0 (optional)\nType: `string|number|date`    \nDefault: 0  \nThe value used to compute the y position of the other side of the rectangle.\n\n#### color (optional)\nType: `string|number`\nThe color of a bar in the series. By default the color is interpreted as number to be scaled to a color range. This can be over-ridden by providing the prop colorType=\"literal\" to the series itself. This property can also be defined on the series level. See [colors](colors.md).\n\n#### opacity (optional)\nType: `number|Object`  \nOpacity of the individual box to be rendered. By default opacity is scaled by `literal`, so the exact value provided will be used. This property can also be defined on the series level.\n\n#### stroke (optional)\nType: `number|Object`  \nThe color of the outline of the box to be rendered. When this value is not provided the color attribute is used instead. This property can also be defined on the series level. See [colors](colors.md).\n\n#### fill (optional)\nType: `number|Object`  \nThe color of the inside of the box to be rendered. When this value is not provided the color attribute is used instead. This property can also be defined on the series level. See [colors](colors.md).\n\n## Series API Reference\n\n#### animation (optional)  \nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### color\nType: `string|number`\nThe color for all elements in the series, this property will be over-ridden by color specified in the data attribute. See [colors](colors.md).\n\n#### data\nType: `Array<Object>`\nArray of data for the series. See above data format reference.\n\n#### fill\nType: `string|number`\nThe inner color for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### opacity\nType: `string|number`\nThe opacity for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n#### stroke\nType: `string|number`\nThe outer color for all elements in the series, this property will be over-ridden by color specified in the data attribute.\n\n### style\nType: `object`\nA list of CSS properties to style the series outside of the explicitly set properties. Note that it will override all other properties (ie fill, stroke, opacity, color). See [style](style.md)\n\n## Interaction handlers\n\n#### onNearestX (optional)\nType: `function(value, {event, innerX, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose x position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onNearestXY (optional)\nType: `function(value, {event, innerX, innerY, index})`  \nA callback function which is triggered each time the mouse pointer moves. It can access the datapoint of the mark whose position is the closest to that of the cursor. \nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the mark;\n- `innerY` is the top position of the mark;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\nSee [interaction](interaction.md)\n\n#### onValueMouseOver (optional)\nType: `function(d, {event})`  \n`mouseover` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.\n\n#### onValueMouseOut (optional)\nType: `function(d, {event})`  \n`mouseout` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n\n#### onValueClick (optional)\nType: `function(d, {event})`  \n`click` event handler for the elements corresponding separate data points. First argument received is, `d`, the relevant data point, and second an object with the only `event` property.  \n\n#### onSeriesMouseOver (optional)\nType: `function({event})`  \n`mouseover` event handler for the entire series. Receives an object as argument with the `event` property.\n\n#### onSeriesMouseOut (optional)\nType: `function({event})`  \n`mouseout` event handler for the entire series. Receives an object as argument with the `event` property.\n\n#### onSeriesClick (optional)\nType: `function({event})`  \n`click` event handler for the entire series. Receives an object as argument with the `event` property.\n","fileName":"rect-series.md"},{"text":"# Sankey\n\nNote: This component is in alpha.\n\n\n\n### Usage\n\n```jsx\nimport {Sankey} from 'react-vis';\n\nconst nodes = [{name: 'a'}, {name: 'b'}, {name: 'c'}];\nconst links = [\n  {source: 0, target: 1, value: 10},\n  {source: 0, target: 2, value: 20},\n  {source: 1, target: 2, value: 20}\n];\n\n<Sankey\n  nodes={nodes}\n  links={links}\n  width={200}\n  height={200}\n/>\n```\n\n### Api\n\n##### width (required, pixels)\n##### height (required, pixels)\n##### nodes (required)\n\nAn array of objects matching the following shape:\n\n```\n{\n  name: String,\n  color: String,\n  opacity: Number,\n  key: String\n}\n```\n\nThe name will be displayed as a label next to its node.\n\nAll these fields are optional.\n\n##### links (required)\n\nAn array of objects matching the following shape, where both `source` and `target`\nare the indexes of the nodes they intent to represent, and `value` that would\nmatch the height of the path link.\n\n```\n{\n  // required\n  source: Number,\n  target: Number,\n  value: Number,\n  // optional\n  color: String,\n  opacity: Number,\n  key: String\n}\n```\n\n##### margin (pixels)\n\nThe margin that will be applied to each side of the Sankey.\n\nDefaults to `20`.\n\n##### nodeWidth (pixels)\n\nWidth of the nodes.\n\nDefaults to `10`.\n\n##### nodePadding (pixels)\n\nPadding between each node.\n\nDefaults to `10`.\n\n##### align\n\nThe alignment used for the sankey ([example](http://bl.ocks.org/vasturiano/b0b14f2e58fdeb0da61e62d51c649908)).\nCan be `justify`, `center`, `left`, `right`.\n\nDefaults to `justify`.\n\n##### layout\n\nThe number of passes the sankey algorithm will do in order to arrange positioning.\n\nDefaults to `50`.\n\n##### hasVoronoi\n\nDetermine if the node selection will be done using a voronoi or not. Although less\nprecise, it can help providing a better interactive experience to the user.\n\nDefaults to `false`.\n\n##### hideLabels\n\nHide the display of the node names if specified to true.\n\nDefaults to `false`.\n\n##### onClick\n\nCallback when clicking a node, or the voronoi assigned to this node, pass the node.\n\n##### onHover\n\nCallback when hovering a node, or the voronoi assigned to this node, pass the node.\n\n##### onBlur\n\nCallback when bluring a node, or the voronoi assigned to this node, pass the node.\n","fileName":"sankey.md"},{"text":"## Scales and data\n\n### Data\n\nReact-Vis charts are made of Series components - LineSeries, BarSeries and so on and so forth.\nEach of these Series components requires a `data` property, through which we pass an array of objects.\n\nThese properties correspond to various visual characteristics of the corresponding marks. For example, x and y, which are required for most series types, affect the position of each mark. Each series type takes more properties, though, which are described in the series section.\n\nHere is how a simple dataset is transformed in some simple charts:\n\n\n\n```jsx\nconst data = [\n  {x: 0, y: 8},\n  {x: 1, y: 5},\n  {x: 2, y: 4},\n  {x: 3, y: 9},\n  {x: 4, y: 1},\n  {x: 5, y: 7},\n  {x: 6, y: 6},\n  {x: 7, y: 3},\n  {x: 8, y: 2},\n  {x: 9, y: 0}\n];\n\n...\n\n<XYPlot height={200} width={200}>\n  <VerticalBarSeries data={data} />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <LineSeries data={data} />\n</XYPlot>\n<XYPlot height={200} width={200}>\n  <MarkSeries data={data} />\n</XYPlot>\n\n```\n\nBy the way: can you guess what this dataset is? Answer at the end of the document.\n\n### Scales\n\nScales are what actually transform the values of the properties in the data objects into visual attributes. In the example above, for instance, the third object is {x: 2, y: 4}. But the corresponding rectangle is 39.45px from the left and 105.56px from the top of the top left corner of the chart. How? Scales.\n\nReact-vis scales are designed so that as often as possible, you shouldn't have to do anything; yet they give you control to override anything they do.  \n\nThe notion of scales and the corresponding vocabulary are directly taken from d3js.\nScales have a type, a range and a domain. For a given chart, there are multiple scales: there's one scale per attribute. Attributes include x position, y position, color, size, angle etc. Again, not all attributes are applicable in all series.\n\nWe are following the definition of scales which was given by Mike Bostock: _scales are functions that map from an input domain to an output range_.\n\nUnder the hood, scales have a default type; a default domain can be inferred automatically from the data and, depending on the attribute, there's either a default range, or it is being generated depending on context.\n\nFor example, for x and y:\n- the default type is a linear scale (the relationship between the value in the data object and the actual position of the mark is of the form: y = ax + b ),\n- the domain is defined by the smallest and highest values for found in the dataset - in the above example, both x and y vary from 0 to 9, so the domains are [0, 9] for both the x- and the y- scale,\n- and the range is the total width of the XYPlot minus the margin.\n\nAll of this is sensible most of the time.  \n\nScales transform each datapoint into visual characteristics for a mark, so, for a given attribute, they only work if the corresponding data property exists. The property in the datapoint MUST have the same name as the attribute. You can have all the properties you want in your datapoint object, but to position the mark from left to right, you NEED a x property.\n\n### Available scales by series type:\n\nHere is what attribute is available as a scale per series type, and what is the default scale type:\n\n| Series              | angle  | angle0 | color      | fill       | opacity    | radius | radius0 | size   | stroke     | x      | x0     | y      | y0     |\n|---------------------|--------|--------|------------|------------|------------|--------|---------|--------|------------|--------|--------|--------|--------|\n| [ArcSeries](arc-series.md)           | linear | linear | linear     | linear     | literal    | linear | linear  |        | linear     | linear |        | linear |        |\n| [AreaSeries](area-series.md)          |        |        | / series | / series | / series |        |         |        | / series | linear |        | linear | linear |\n| [ContourSeries](contour-series.md)       |        |        | linear*    |            |            |        |         |        |            | linear |        | linear |        |\n| [HeatmapSeries](heatmap-series.md)       |        |        | linear     |            | literal    |        |         |        | linear     | linear |        | linear |        |\n| [HorizontalBarSeries](bar-series.md) |        |        | linear     | linear     | literal    |        |         |        | linear     | linear | linear | linear |        |\n| [LabelSeries](label-series.md)         |        |        |            |            |            |        |         |        |            | linear |        | linear |        |\n| [LineSeries](line-series.md)          |        |        | / series |            | / series |        |         |        | / series | linear |        | linear |        |\n| [MarkSeries](mark-series.md)          |        |        | linear     | linear     | literal    |        |         | linear | linear     | linear |        | linear |        | \n| [PolygonSeries](polygon-series.md)       |        |        | / series |            |            |        |         |        |            | linear |        | linear |        |\n| [RectSeries](rect-series.md)          |        |        | linear     | linear     | literal    |        |         |        | linear     | linear | linear | linear | linear |\n| [VerticalBarSeries](bar-series.md)   |        |        | linear     | linear     | literal    |        |         |        | linear     | linear |        | linear | linear |\n\nFor Heatmap series, while you can pass a colorDomain and a colorRange, you cannot override the type of scale for colors.\n\n\"Per series\" means that it's possible to pass a value to the series as a whole, but not per data point.\n\nIf am attribute is not available as a scale for a given series, all values passed in the corresponding property will be ignored. For instance, if you use a dataset that has fill properties, it will be ignored for LineSeries.\n\nThis table is also meant to be used for derived series. Canvas series have the same interface as SVG series. HorizontalRectSeries and VerticalRectSeries take the same attribute as RectSeries. And LineMarkSeries take the same atttribute as Line and Mark series.\n\n### Scale properties\n\nTo redefine a scale, you must pass a prop to the series that uses that scale. The prop names are based on the name of the attribute: name + Domain, name + Range, name + Type, name + Padding (for instance: yDomain, colorType, xRange).\n\n* `[name]Domain` (optional)  \n  Type: `Array`  \n  Array of values to visualize from. If domain is not passed, it will be calculated from the values which are passed to component.\n* `[name]Padding` (optional)  \n  Type: `Number`  \n  A percentage that will pad your `[name]Domain`. If the padding not passed `[name]Domain` will not be padded. Note: if you pass `[name]Domain` and it is not calculated from the values, padding will not be used.\n* `[name]Range` (optional)\n  Type: `Array`  \n  Array of real-world values to visualize to. If range is not passed, the defaults (depend on visualization type) will be applied.\n* `[name]Type` (optional)  \n  Type: `('linear'|'ordinal'|'category'|'time'|'time-utc'|'log'|'literal')`  \n  Default: `'linear'`  \n  Type of the scale. Each scale type can be one of following values:\n    * `'linear'`  \n    Continuous scale, that works with numbers. Similar to [d3.scaleLinear](https://github.com/d3/d3-scale/blob/master/README.md#scaleLinear).\n    * `'ordinal'`  \n    Ordinal scale, works with numbers and strings. Similar to [d3.scaleOrdinal](https://github.com/d3/d3-scale/blob/master/README.md#ordinal-scales).\n    * `'category'`  \n    Categorical scale, each new value gets the next value from the range. Similar to d3.scale.category\\[Number\\], but works with other values besides colors.\n    * `'time'`  \n    Time scale. Similar to [d3.scaleTime](https://github.com/d3/d3-scale/blob/master/README.md#time-scales).\n    * `'time-utc'`  \n    Time UTC scale. Similar to [d3.scaleUtc](https://github.com/d3/d3-scale/blob/master/README.md#scaleUtc)\n    * `'log'`  \n    Log scale. Similar to [d3.scaleLog](https://github.com/d3/d3-scale/blob/master/README.md#log-scales).\n    * `'literal'`  \n    Returns exactly the value that was given to it. Similar to [d3.scaleIdentity](https://github.com/d3/d3-scale#scaleIdentity), except that it does NOT coerce data into numbers. This is useful for precisely specifying properties in the data, eg color can be specified directly on the data.\n\n### Overriding scales\n\nScales can be defined either at the XYPlot level, in which case they apply to the whole chart, or at the series level. Scales defined at the series level override those defined at the XYPlot level.\n\nThe scales provided to each individual series don't have to have the same parameters. For instance, if you wanted to do a dual-axis chart, you could provide a different yDomain and yRange to two data series (use at your own risk).\n\n### Other uses of scales\n\nScales can also be used in [Axes](axes.md) and in [Gridlines](grids.md). You can pass an x-scale (so xDomain, xRange, xPadding, xType) to an XAxis or a VerticalGridLines component, and a y-scale (so yDomain, yRange, yPadding, yType) to a YAxis or HorizontalGridLines component. These scale parameters don't have to be the same as the ones passed to your series.\n\nDid you guess that this data set was the digits sorted alphabetically? eight, five, four...\n","fileName":"scales-and-data.md"},{"text":"## Series\n\nThe library supports several types of series:\n\n* [ArcSeries](arc-series.md) for radial arcs such as might be found in pie charts.\n* [AreaSeries](area-series.md) for area charts;\n* [BarSeries](bar-series.md) for discrete bar charts, covers (covers HorizontalBarSeries and VerticalBarSeries);\n* [ContourSeries](contour-series.md) for making contour density plots;\n* [HeatmapSeries](heatmap-series.md) for heat maps.\n* [LabelSeries](label-series.md) for adding annotations to charts\n* [LineMarkSeries](line-series.md) is a shorthand to place marks (e.g. circles) on lines;\n* [LineSeries](line-series.md) for lines;\n* [MarkSeries](mark-series.md) for scatterplots;\n* [PolygonSeries](polygon-series.md) for arbitrary SVG shapes\n* [RectSeries](rect-series.md) for arbitrary histograms and other continuous variable boxes. (covers HorizontalRectSeries and VerticalRectSeries)\n\nEach series provides following API:\n\n#### data\nType: `Array<Object>`\nArray of data for the series.\n\n#### x\nType: `number|Object`\nExact X position of all series points in pixels or a series object.\n\n#### y (optional)\nType: `number|Object`\nExact Y position of all series points in pixels or a series object.\n\n#### color (optional)\nType: `string|Object`\nExact color for all series points or a series object.\n\n#### size (optional)\nType: `number|Object`\nExact size for all series points in pixels or a series object.\n\n#### opacity (optional)\nType: `number|Object`\nExact opacity for all series points in pixels or a series object.\n\n#### className (optional)\nType: `string`\nProvide an additional class name for the series.\n\n#### onNearestX (optional)\nType: `function(value, info)`\nA callback function which is triggered each time when the mouse pointer gets close to some X value.\nCallback is triggered with two arguments. `value` is the data point, `info` object has following properties:\n- `innerX` is the left position of the value;\n- `index` is the index of the data point in the array of data;\n- `event` is the event object.\n\n#### onValueMouseOver (optional)\nType: `function(d, info)`\n`mouseover` event handler for the elements corresponding separate data points `d` is a data point, `info` is an object with the only `event` property.\n**NOTE**: This event handler is *not* triggered for AreaSeries and LineSeries.\n\n#### onValueMouseOut (optional)\nType: `function(d, info)`\n`mouseout` event handler for the elements corresponding separate data points. `d` is a data point, `info` is an object with the only `event` property.\n**NOTE**: This event handler is *not* triggered for AreaSeries and LineSeries.\n\n#### onValueClick (optional)\nType: `function(d, info)`\n`click` event handler for the elements corresponding separate data points. `d` is a data point, `info` is an object with the only `event` property.\n**NOTE**: This event handler is *not* triggered for AreaSeries and LineSeries.\n\n#### onSeriesMouseOver (optional)\nType: `function(info)`\n`mouseover` event handler for the entire series. Received `info` object as argument with the only `event` property.\n\n#### onSeriesMouseOut (optional)\nType: `function(info)`\n`mouseout` event handler for the entire series. Received `info` object as argument with the only `event` property.\n\n#### onSeriesClick (optional)\nType: `function(info)`\n`click` event handler for the entire series. Received `info` object as argument with the only `event` property.\n\n#### style (optional)\nType: `object`\nAn object which holds CSS properties that will be applied to the SVG element(s) rendered by the series. This allows you to style series beyond the other explicitly defined properties and without having to use CSS classnames and stylesheets. For instance, you can set the stroke-linejoin style of a line series to \"round\":\n```jsx\n<LineSeries\n  data={data}\n  style={{strokeLinejoin: \"round\"}}\n/>\n```\nLineMark series is a composite series, and as such, it's possible to separate style instructions for the line and the mark part by putting them under a \"line\" and a \"mark\" property respectively:\n\n```jsx\n<LineMarkSeries\n  data={data}\n  style={{\n  \t// affect both the line and the mark part\n  \tstroke: \"red\",\n  \t.line: {\n  \t  // affects just the line series\n  \t  strokeWidth: 2\n  \t},\n  \t.mark {\n  \t  // affects just the mark series\n  \t  strokeWidth: 4\n  \t}\n  }}\n/>\n```\n\nNote that style information passed through the style property will override those passed through props.\n```jsx\n<MarkSeries\n  data={data}\n  /// all the points are red\n  style={{fill: \"red\"}}\n/>\n```\n\n#### animation (optional)\nSee the [XYPlot](xy-plot.md)'s `animation` section for more information.\n","fileName":"series.md"},{"text":"## Style\n\nIn order to control the look and feel of your React-Vis components, you have four strategies.\n\n### the React-Vis style sheet\nReact-Vis comes with a default style sheet. You need to import it or otherwise link it to your app (as shown in the [getting started](tutorial/getting-started.md) page), or you may overwrite it. \n\n### Class names\nYou may also use the class names of the React-Vis component to style them through your own stylesheets, or your own style strategies. \nFurthermore, all series components accept a `className` property, which adds a class of your own choosing to the element. \nNon-series elements (i.e. [gridlines](grids.md) or [hints](hint.md)) do not take a className property.\n\n### Component-specific properties\nVirtually every component accept several properties that affects its appearance. For instance, [line series](line-series.md) take a `color` property to control the stroke color of the line, but others as well such as strokeWidth that controls its thickness. Each of these is described in detail for each component. \n\n### Style property\nFinally, components can also accept a special property called `style`. This let you pass an object to the component. The keys of that object are CSS properties, camel-cased (ie `stroke-width` would be written `strokeWidth`) and values are what you'd want to set those properties to. These are the same conventions than when [passing style](https://facebook.github.io/react/docs/dom-elements.html) to a standard DOM element with React.\n\n```javascript\n<LineSeries\n  data={data}\n  style={{strokeWidth: 2}}\n/>\n```\n\nSome React-Vis components are composite in the sense that they group several elements that you may want to style distinctly. For instance, the [line-mark series](line-mark-series.md) combines a [line series](line-series.md) and a [mark series](mark-series.md). While you could pass the same style object to both, you can also use special properties (in this case, `line` and `mark`) to send a specific style object to either or both sub-components. \n\n```javascript\n<LineMarkSeries\n  data={data}\n  color=\"red\"\n  style={{mark:{stroke: 'white'}}}\n/>\n```\nIn that example, without the style property, both lines and marks would be red. Without specifying `mark` in the style property, the stroke color of both lines and marks would be white. Here, the line remains red, and the marks are going to be red (their fill color) but with a white outline.\n","fileName":"style.md"},{"text":"# Sunbursts\n\nSunbursts are a powerful way to demonstrate part to whole relationships. While they certainly have the many of easily criticized problems of pie charts, they allow for\nat a glance understanding of deeply nested systems. This could be useful for understanding for funnels problems or distributions of nested groups (eg how does my cities performance compare to other cities in my country?).\n\n\n\nThe `Sunburst` is a thin data processing wrapper on an XYPlotted [ArcSeries](arc-series.md), it generates highly re-stylable SVG! Any props that are available in the arc series are also available here. Additionally it copies the data format of the treemap, so if you have data prepped to drop into the tree map, you can use that same data to get a sunbrust.\n\n## Usage\n\nImport the `Sunburst` component:\n```jsx\nimport {Sunburst} from 'react-vis';\n```\n\nAdd the following code to your render function:\n```jsx\n<Sunburst\n  hideRootNode\n  colorType=\"literal\"\n  data={data}\n  height={300}\n  width={350}/>\n```\n\nLike other systems that make use of d3's hierarchy layout system we ask that our data be presented to us in a tree like structure.\nHere's a slice of the famous d3-flare dataset:\n\n\n```javascript\nconst myData = {\n \"title\": \"analytics\",\n \"color\": \"#12939A\",\n \"children\": [\n  {\n   \"title\": \"cluster\",\n   \"children\": [\n    {\"title\": \"AgglomerativeCluster\", \"color\": \"#12939A\", \"size\": 3938},\n    {\"title\": \"CommunityStructure\", \"color\": \"#12939A\", \"size\": 3812},\n    {\"title\": \"HierarchicalCluster\", \"color\": \"#12939A\", \"size\": 6714},\n    {\"title\": \"MergeEdge\", \"color\": \"#12939A\", \"size\": 743}\n   ]\n  },\n  {\n   \"title\": \"graph\",\n   \"children\": [\n    {\"title\": \"BetweennessCentrality\", \"color\": \"#12939A\", \"size\": 3534},\n    {\"title\": \"LinkDistance\", \"color\": \"#12939A\", \"size\": 5731},\n    {\"title\": \"MaxFlowMinCut\", \"color\": \"#12939A\", \"size\": 7840},\n    {\"title\": \"ShortestPaths\", \"color\": \"#12939A\", \"size\": 5914},\n    {\"title\": \"SpanningTree\", \"color\": \"#12939A\", \"size\": 3416}\n   ]\n  },\n  {\n   \"title\": \"optimization\",\n   \"children\": [\n    {\"title\": \"AspectRatioBanker\", \"color\": \"#12939A\", \"size\": 7074}\n   ]\n  }\n ]\n}\n```\n\nFirst, note the recursive tree relationship: each node has a title, and an array of children.\nThis pattern continues until we reach the leaves, where we declare the size of the leaves. This value is rolled up, so that\nthe \"cluster\" node has  3938 + 3812 + 6714 + 743 = 15207 size units.\n\n\n## API Reference\n\n#### width\nType: `number`  \nWidth of the component.\n\n#### height\nType: `number`  \nHeight of the component.\n\n#### data\nType: `Object`  \nThe data for the component. The `data` property is a tree-like structure.  \nEach point consists of following properties:\n\n* `title`  \n  Type: `string`  \n  The title to show inside the cell. Might be a string or a React component.\n* `size`  \n  Type: `number`  \n  The relative size of the cell.\n* `color` (optional)  \n  Type: `number` or `string`\n  The value to visualize the color with.\n* `label` (optional)  \n  Type: `string`\n  The label to be attached for the current node.\n* `labelStyle` (optional)  \n  Type: `object`\n  The style of the attached label. Example `{labelStyle: {fontSize: 15}, ...}`\n* `children` (optional)  \n  Type: `Array`  \n  The children for the leaf.\n\n\n\n#### hideRootNode (optional)\nType: `boolean`\nSimple boolean on whether or not to show the root node of the tree.\n\n#### children (optional)\nType: `react components`\nSunburst can accept react components as children if you wish to to annotate your diagram.\n\n#### animation (optional)\nType: `boolean|Object`\nPlease refer to [Animation](animation.md) doc for more information.\n\n\n\n#### onValueClick (optional)\nType: `function`\n- Should accept arguments (arc node, domEvent)\n\nPass in a function that will be called on click on a given arc.\n\n#### onValueMouseOver (optional)\nType: `function`\n- Should accept arguments (arc node, domEvent)\n\nPass in a function that will be called on mouseEnter on a given arc.\n\n#### onValueMouseOut (optional)\nType: `function`\n- Should accept arguments (arc node, domEvent)\n\nPass in a function that will be called on mouseOut on a given arc.\n","fileName":"sunburst.md"},{"text":"# Treemap\n\nTreemaps are a splendid way to represent data that has a nested aspect to it. They allow for the easy display of complicated\nrelative information, such as nested-part-to-whole relationships in a easy to grock fashion. Checkout [the wikipedia page](https://en.wikipedia.org/wiki/Treemapping) or Ben Shneiderman's excellent [History of treemaps](http://www.cs.umd.edu/hcil/treemap-history/index.shtml) for more information.\n\n\n\nThe `treemap` in react-vis builds a series of nested divs (allow for easy and highly restyleable trees). We offer ten different layout\nstrategies, enabling the construction of standard treemaps, circle packed treemaps, and partition trees (also called icicle diagrams).\n\n## Usage\n\nImport the `treemap` component:\n```jsx\nimport {Treemap} from 'react-vis';\n```\n\nAdd the following code to your render function:\n```jsx\n<Treemap\n  title={'My New Treemap'}\n  width={300}\n  height={300}\n  data={myData}\n  />\n```\n\nLike other systems that make use of d3's hierarchy layout system we ask that our data be presented to us in a tree like structure.\nHere's a slice of the famous d3-flare dataset:\n\n\n```javascript\nconst myData = {\n \"title\": \"analytics\",\n \"color\": \"#12939A\",\n \"children\": [\n  {\n   \"title\": \"cluster\",\n   \"children\": [\n    {\"title\": \"AgglomerativeCluster\", \"color\": \"#12939A\", \"size\": 3938},\n    {\"title\": \"CommunityStructure\", \"color\": \"#12939A\", \"size\": 3812},\n    {\"title\": \"HierarchicalCluster\", \"color\": \"#12939A\", \"size\": 6714},\n    {\"title\": \"MergeEdge\", \"color\": \"#12939A\", \"size\": 743}\n   ]\n  },\n  {\n   \"title\": \"graph\",\n   \"children\": [\n    {\"title\": \"BetweennessCentrality\", \"color\": \"#12939A\", \"size\": 3534},\n    {\"title\": \"LinkDistance\", \"color\": \"#12939A\", \"size\": 5731},\n    {\"title\": \"MaxFlowMinCut\", \"color\": \"#12939A\", \"size\": 7840},\n    {\"title\": \"ShortestPaths\", \"color\": \"#12939A\", \"size\": 5914},\n    {\"title\": \"SpanningTree\", \"color\": \"#12939A\", \"size\": 3416}\n   ]\n  },\n  {\n   \"title\": \"optimization\",\n   \"children\": [\n    {\"title\": \"AspectRatioBanker\", \"color\": \"#12939A\", \"size\": 7074}\n   ]\n  }\n ]\n}\n```\n\nFirst, note the recursive tree relationship: each node has a title, and an array of children.\nThis pattern continues until we reach the leaves, where we declare the size of the leaves. This value is rolled up, so that\nthe \"cluster\" node has  3938 + 3812 + 6714 + 743 = 15207 size units.\n\n#### Hints\n\n- It is often quite effective to use the literal scale type for Treemap's color attribute, as this allows highly granular control\nover all of the nodes.\n\n- It can useful to encode opacity to indicate tree depth, however because each tree leaf is a nested div this gets a little\ntricky. One technique is to to compute the effective RGBA to hex value, check out [this link](viget.com/inspire/equating-color-and-transparency)\nfor more details.\n\n- If your not sure when to use a treemap, remember they provide an easy drop in relationship for pie charts.\n\n## API Reference\n\n#### width\nType: `number`  \nWidth of the component.\n\n#### height\nType: `number`  \nHeight of the component.\n\n#### padding\nType: `number`  \nThe padding between cells the cells of the heatmap in pixels.\n\n#### data\nType: `Object`  \nThe data for the component. The `data` property is a tree-like structure.  \nEach point consists of following properties:\n\n* `title`  \n  Type: `string`  \n  The title to show inside the cell. Might be a string or a React component.\n* `size`  \n  Type: `number`  \n  The relative size of the cell.\n* `opacity` (optional)  \n  Type: `number`  \n  The value to visualize the opacity with.\n* `color` (optional)  \n  Type: `number` or `string`\n  The value to visualize the color with.\n* `children` (optional)  \n  Type: `Array`  \n  The children for the leaf.\n\n#### animation (optional)\nType: `boolean|Object`\nPlease refer to [Animation](animation.md) doc for more information.\n\n#### onLeafClick (optional)\nType: `function`\n- Should accept arguments (leafNode, domEvent)\n\nPass in a function that will be called on click on a given leaf.\n\n#### onLeafMouseOver (optional)\nType: `function`\n- Should accept arguments (leafNode, domEvent)\n\nPass in a function that will be called on mouseEnter on a given leaf.\n\n#### onLeafMouseOut (optional)\nType: `function`\n- Should accept arguments (leafNode, domEvent)\n\nPass in a function that will be called on mouseOut on a given leaf.\n\n#### mode (options)\nType: `string`\n- One of squarify, resquarify, slice, dice, slicedice, binary, circlePack, partition, partition-pivot\n\nThis modifies the tiling strategy for the treemap, for more information see the [d3 hierarchy docs](https://github.com/d3/d3-hierarchy).\n","fileName":"treemap.md"},{"text":"# XYPlot\n\nXYPlot allows you to make line charts, area charts, scatterplots, heat maps, etc with animations and different interactions between them.\n\nCurrently following components are used for this purpose:\n\n* XYPlot to wrap all the items.\n* [Grids](grids.md) to show vertical and horizontal grids.\n* [Axes](axes.md) to show X and Y axis.\n* [Different kinds of series](series.md) for line/area/bar charts, scatterplots, heat maps, etc.\n* [Hint](hint.md) to show the selected hint.\n* [Crosshair](crosshair.md) for crosshairs.\n\n## Usage\n\nImport the necessary components from the library&hellip;\n\n```jsx\nimport {XYPlot, XAxis, YAxis, HorizontalGridLines, LineSeries} from 'react-vis';\n```\n\n&hellip; and add the following code to your `render` function:\n\n```jsx\n<XYPlot\n  width={300}\n  height={300}>\n  <HorizontalGridLines />\n  <LineSeries\n    color=\"red\"\n    data={[\n      {x: 1, y: 10},\n      {x: 2, y: 5},\n      {x: 3, y: 15}\n    ]}/>\n  <XAxis title=\"X\" />\n  <YAxis />\n</XYPlot>\n```\n\n## Common concepts\n\nXYPlot is a wrapper for series, hints, axes and other components. Most of these components do not require any properties by default, however it is expected that the user will pass the `data` property into each series.\n\n`data` is an array of objects. Each item is some point on the chart. Object may contain following properties:\n\n* `x`\n* `y`\n* `opacity` (optional)\n* `fill` (optional)\n* `stroke` (optional)\n* `strokeWidth` (optional), `strokeStyle` (optional) - to control the width of the line series and whether they are dashed or solid.\n* `color` (optional, used instead of `fill` and `stroke` if none of them is passed)\n* `size` (optional)\n* `style` (optional) - css properties as an object.\n\nIf the property is not passed in any of the objects, the property is not visualized. The user can override the way how properties are visualized by passing custom range, domain or type of scales to the series or the entire chart (please see [Series](series.md) for more info).\n\nNot all properties can be visualized in each series. Here's a short comparison of them:\n\n|                      | `x` | `y` | `color` | `opacity` | `size` |\n|----------------------|-----|-----|---------|-----------|--------|\n| [LineSeries](line-series.md)  |  +  |  +  | +       |           |        |\n| `AreaSeries`         |  +  |  +  | +       |           |        |\n| [LineMarkSeries](line-series.md)     |  +  |  +  | +       |     +     | +      |\n| `MarkSeries`         |  +  |  +  | +       |     +     | +      |\n| [VerticalBarSeries](bar-series.md)  |  +  |  +  | +       |     +     |        |\n| [HorizontalBarSeries](bar-series.md)|  +  |  +  | +       |     +     |        |\n| `VerticalRectSeries`  |  +  |  +  | +       |     +     |        |\n| `HorizontalRectSeries`|  +  |  +  | +       |     +     |        |\n| [HeatmapSeries](heatmap-series.md)      |  +  |  +  | +       |     +     |        |      |\n\n\n### A note on ordering\n\nXYPlot is pretty flexible, and can accept most kinds of things DOM, SVG, really whatever react can build. As far as XYPlot is concerned there are two types of components in the world: those that can be rendered as part of an SVG tree and those that can't. It separates it's children into these two groups, and clusters the SVG elements under a root svg tag in order and then presents each of the remaining children in order. To wit, given a react configuration like:\n\n```javascript\n<XYPlot>\n  <XAxis />\n  <YAxis />\n  <RectSeries {...props}/>\n  <Hint className=\"first-hint\"/>\n  <Hint className=\"second-hint\"/>\n</XYPlot>\n```\nWould generate HTML something like:\n\n```javascript\n<div class=\"rv-xy-plot\">\n  <svg>\n    <svg for XAxis />\n    <svg for YAxis />\n    <svg for RectSeries />\n  </svg>\n  <div class=\"rv-hint first-hint\">...</div>\n  <div class=\"rv-hint second-hint\">...</div>\n</divt>\n```\n\nThe TLDR here is that *ORDER MATTERS*! If you want the elements to appear in a different order, reorder them!\n\n## API Reference\n\n### XYPlot\n\n`XYPlot` is a component that wraps series, axis and grids, hints, etc and seamlessly provides necessary dimensions, sizes and scales into its children.  \n`XYPlot` may or may not contain axes, grids, hints, crosshairs or series.\n\n#### width\nType: `number`  \nWidth of the chart. The width should be passed.\n\n#### height\nType: `number`  \nHeight of the component. The height should be passed.\n\n#### className (optional)\nType: `string`  \nDOM classNames to be added to the wrapper component.\n\n#### margin (optional)\nType: `Object`  \nDefault: `{left: 40, right: 10, top: 10, bottom: 40}`\nMargin around the chart.\n\n#### stackBy (optional)\nType: `string`  \nStack the chart by the given attribute. If the attribute is `y`, the chart is stacked vertically; if the attribute is `x` then it's stacked horizontally.\n\n### style (optional)\nType: `object`\nCSS properties that will affect this wrapper component. Those will be applied to the SVG element in which other react-vis components will be created.  \n\n```jsx\n<XYPlot\n  stackBy=\"y\"\n  width={300}\n  height={300}>\n  <LineSeries\n    data={[\n      {x: 1, y: 10},\n      {x: 2, y: 5},\n      {x: 3, y: 15}\n    ]}/>\n  <LineSeries\n    data={[\n      {x: 1, y: 12},\n      {x: 2, y: 21},\n      {x: 3, y: 2}\n    ]}/>\n</XYPlot>\n```\n\n*NOTE* in order to stack properly react-vis expects each x value in each series to be present (assuming stackBy: 'x', the same applies to stackBy 'y', just transposed). To wit, if our data looks like\n```\nconst seriesOne = [\n  {x: 1, y: 10},\n  {x: 3, y: 15}\n];\n\nconst seriesTwo = [\n  {x: 1, y: 10},\n  {x: 2, y: 5},\n  {x: 3, y: 15}\n];\n\nconst seriesThree = [\n  {x: 3, y: 15}\n];\n\n```\n\nwould render weirdly (eg boxes would not lump together at the bottom of the chart). To avoid this, simply provide zeroes for empty cells\n\n```\nconst seriesOne = [\n  {x: 1, y: 10},\n  {x: 2, y: 0},\n  {x: 3, y: 15}\n];\n\nconst seriesTwo = [\n  {x: 1, y: 10},\n  {x: 2, y: 5},\n  {x: 3, y: 15}\n];\n\nconst seriesThree = [\n  {x: 1, y: 0},\n  {x: 2, y: 0},\n  {x: 3, y: 15}\n];\n\n```\n\nWill render beautifully!\n\n#### onMouseLeave (optional)\nType: `function()`  \nThe function that is triggered each time the mouse leaves the component.\n\n#### onMouseMove (optional)\nType: `function()`  \nThe function that is triggered each time mouse moves over at the component.\n\n#### onMouseEnter (optional)\nType: `function()`  \nThe function that is triggered each time the mouse enters the component.\n\n#### animation (optional)\nType: `{duration: number}|boolean`\nDefault: `false`  \nAnimation config, which is automatically passed to all children, but can be overrided for the each child.  \nIf `false` is passed, then the child components *will not be* animated.  \nIf `true` is passed then the child components *will be* animated with the default settings.  \nIf an object is passed, then the child components *will be* animated with the given settings.\n","fileName":"xy-plot.md"},{"text":"\n\n[Source code](https://github.com/uber/react-vis/blob/master/examples/force-directed-graph/force-directed-graph.js)\n","fileName":"examples/building-things-other-than-charts.md"},{"text":"\n\n\n## Extensibility\n\nreact-vis is easily extensible! If we don't have what you want it's easy to make! For instance, the above chart\nwas made by simply extending abstract series and adding a little sugar.\n\n[Source code](https://github.com/uber/react-vis/blob/master/examples/candlestick/candlestick.js)\n","fileName":"examples/extensibility.md"},{"text":"<!-- STYLETYPE:\"example-page\" -->\n\n\n[Source code](https://github.com/uber/react-vis/blob/master/examples/history/history-example.js)\n","fileName":"examples/history-example.md"},{"text":"<!-- STYLETYPE:\"example-page\" -->\n\n\nThis demo explores the concept of \"Responsive Data Visualization\" (As coined by Nick Rabinowitz). The basic notion is lifted from responsive design: some features work for some screen resolutions, while others do not. Responsive design determines whether or not to use a given feature by consulting an aspect ratio (width by height). Through this notation we are able to create beautiful web experiences that work seamlessly between phones, tablets, and computers. Taking this idea on step farther we introduce a third element into the fray: data size.\n\nIn data visualization, we often need to create applications that work with enormous ranges of sizes of data. Sometimes the data might be small (10 - 100 rows), or it might be gigantic (100k-1M+ row): throughout the entire range it just needs to work. Again, following our cues from responsive design, we note that maybe labels on scatterplots look great when you have under 50 data points, but bad when you have 2000. Checkout Nicks [original demo](http://nrabinowitz.github.io/rdv/) for more details on the theory, as well to see his rad implementation in raw d3.\n\n[Scatterplot source code](https://github.com/uber/react-vis/blob/master/examples/responsive-vis/responsive-scatterplot.js)\n\n[Barchart source code](https://github.com/uber/react-vis/blob/master/examples/responsive-vis/responsive-bar-chart.js)\n","fileName":"examples/responsive-vis.md"},{"text":"<!-- STYLETYPE:\"example-page\" -->\n\n\n[Source code](https://github.com/uber/react-vis/blob/master/examples/streamgraph/streamgraph-example.js)\n","fileName":"examples/stream-graph.md"},{"text":"\n\n[Source code](https://github.com/uber/react-vis/blob/master/examples/zoomable-chart/zoomable-chart-example.js)\n","fileName":"examples/zoomable-chart.md"},{"text":"### Install the react-vis module\n\nIf you want to use react-vis in your project, add it from the command line: \n\n```\nnpm install react-vis\n```\n\n(or yarn add react-vis - the following will assume that you use npm for concision's sake but you can substitute yarn if installed)\n","fileName":"getting-started/installing-react-vis.md"},{"text":"### Create a new project with react-vis\n\nLet's create a new vis app from scratch.\nTo do this, let's use [create-react-app](https://github.com/facebookincubator/create-react-app), the popular Facebook scaffold. \n\nIf you haven't installed yet, do so: \n\n```\nnpm install -g create-react-app\n```\n\nAnd now:\n```\ncreate-react-app my-awesome-vis-app\ncd my-awesome-vis-app\nnpm install react-vis\n```\n\nThat's it! you are now ready to create amazing charts. \n\nLet's edit create-react-app's default App.js: \n\n```jsx\nimport React, { Component } from 'react';\nimport './App.css';\nimport '../node_modules/react-vis/dist/style.css';\nimport {XYPlot, LineSeries} from 'react-vis';\n\nclass App extends Component {\n  render() {\n    const data = [\n      {x: 0, y: 8},\n      {x: 1, y: 5},\n      {x: 2, y: 4},\n      {x: 3, y: 9},\n      {x: 4, y: 1},\n      {x: 5, y: 7},\n      {x: 6, y: 6},\n      {x: 7, y: 3},\n      {x: 8, y: 2},\n      {x: 9, y: 0}\n    ];\n    return (\n      <div className=\"App\">\n        <XYPlot height={300} width={300}>\n          <LineSeries data={data} />\n        </XYPlot>\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\nand then on the command line interface:\n\n```\nnpm run start\n```\n\nand your chart is in the browser. \n\nNote that on line 3, I have imported the react-vis stylesheet. There are many ways to do that, and it is actually optional. But apps made with create-react-app will let you import stylesheets directly, so that's a simple way to do so.\n","fileName":"getting-started/new-react-vis-project.md"},{"text":"### Jump right in on codepen!\n\nYou can use react-vis directly on [codepen](https://codepen.io/ubervisualization/pen/BZOeZB) (or equivalent).  \nEach published version of react-vis is accessible via [unpkg.com](https://unpkg.com).\n\nAdd react files, and a link to the latest react-vis version - such as https://unpkg.com/react-vis@1.6.7/dist/dist.min.js.\n\nBut you can simply just use that [pen](https://codepen.io/ubervisualization/pen/BZOeZB) and take it from there.\n","fileName":"getting-started/react-vis-in-codepen.md"},{"text":"### Your first chart\n\nWe tried to make react-vis syntax as close to the traditional react syntax. You have components which have props and possibly children. \n\nEvery react-vis chart is inside a component called XYPlot, for which a height and a width must be specified:\n\n```jsx\n<XYPlot height={300} width = {300} />\n```\n\nAnd all the elements of a chart - series, axes, gridlines, etc. are other components, which will be children of XYPlot.\n\n```jsx\nconst data = [\n  {x: 0, y: 8},\n  {x: 1, y: 5},\n  {x: 2, y: 4},\n  {x: 3, y: 9},\n  {x: 4, y: 1},\n  {x: 5, y: 7},\n  {x: 6, y: 6},\n  {x: 7, y: 3},\n  {x: 8, y: 2},\n  {x: 9, y: 0}\n];\n<XYPlot height={300} width= {300}>\n  <VerticalGridLines />\n  <HorizontalGridLines />\n  <XAxis />\n  <YAxis />\n  <LineSeries data={data} />\n</XYPlot>\n```\n\nAnd like in traditional react, order matters as components are drawn in order. In the previous example, the gridlines are drawn below the line series, but in this next example, they will be drawn above it.\n\n```jsx\n<XYPlot height={300} width= {300}>\n  <LineSeries data={data} />\n  <VerticalGridLines />\n  <HorizontalGridLines />\n  <XAxis />\n  <YAxis />\n</XYPlot>\n```\n\n","fileName":"getting-started/your-first-chart.md"}]